   1              		.file	"fat16.c"
   9              	.Ltext0:
  10              		.align	2
  12              	fat16_dir_entry_seek_callback:
  13              	.LFB7:
  14              		.file 1 "../Library/fat16.c"
   1:../Library/fat16.c **** /* This program is free software; you can redistribute it and/or modify
   2:../Library/fat16.c ****  * it under the terms of the GNU General Public License version 2 as
   3:../Library/fat16.c ****  * published by the Free Software Foundation.
   4:../Library/fat16.c ****  */
   5:../Library/fat16.c **** 
   6:../Library/fat16.c **** #include <stdio.h>
   7:../Library/fat16.c **** 
   8:../Library/fat16.c **** //Debug
   9:../Library/fat16.c **** #include "rprintf.h"
  10:../Library/fat16.c **** 
  11:../Library/fat16.c **** #include "partition.h"
  12:../Library/fat16.c **** #include "fat16.h"
  13:../Library/fat16.c **** #include "fat16_config.h"
  14:../Library/fat16.c **** #include "sd_raw.h"
  15:../Library/fat16.c **** 
  16:../Library/fat16.c **** #include <stdlib.h>
  17:../Library/fat16.c **** #include <string.h>
  18:../Library/fat16.c **** 
  19:../Library/fat16.c **** /**
  20:../Library/fat16.c ****  * \addtogroup fat16 FAT16 support
  21:../Library/fat16.c ****  *
  22:../Library/fat16.c ****  * This module implements FAT16 read and write access.
  23:../Library/fat16.c ****  *
  24:../Library/fat16.c ****  * The following features are supported:
  25:../Library/fat16.c ****  * - File names up to 31 characters long.
  26:../Library/fat16.c ****  * - Unlimited depth of subdirectories.
  27:../Library/fat16.c ****  * - Short 8.3 and long filenames.
  28:../Library/fat16.c ****  * - Creating and deleting files.
  29:../Library/fat16.c ****  * - Reading and writing from and to files.
  30:../Library/fat16.c ****  * - File resizing.
  31:../Library/fat16.c ****  * - File sizes of up to 4 gigabytes.
  32:../Library/fat16.c ****  *
  33:../Library/fat16.c ****  * @{
  34:../Library/fat16.c ****  */
  35:../Library/fat16.c **** /**
  36:../Library/fat16.c ****  * \file
  37:../Library/fat16.c ****  * FAT16 implementation.
  38:../Library/fat16.c ****  *
  39:../Library/fat16.c ****  * \author Roland Riegel
  40:../Library/fat16.c ****  */
  41:../Library/fat16.c **** 
  42:../Library/fat16.c **** /**
  43:../Library/fat16.c ****  * \addtogroup fat16_config FAT16 configuration
  44:../Library/fat16.c ****  * Preprocessor defines to configure the FAT16 implementation.
  45:../Library/fat16.c ****  */
  46:../Library/fat16.c **** 
  47:../Library/fat16.c **** /**
  48:../Library/fat16.c ****  * \addtogroup fat16_fs FAT16 access
  49:../Library/fat16.c ****  * Basic functions for handling a FAT16 filesystem.
  50:../Library/fat16.c ****  */
  51:../Library/fat16.c **** 
  52:../Library/fat16.c **** /**
  53:../Library/fat16.c ****  * \addtogroup fat16_file FAT16 file functions
  54:../Library/fat16.c ****  * Functions for managing files.
  55:../Library/fat16.c ****  */
  56:../Library/fat16.c **** 
  57:../Library/fat16.c **** /**
  58:../Library/fat16.c ****  * \addtogroup fat16_dir FAT16 directory functions
  59:../Library/fat16.c ****  * Functions for managing directories.
  60:../Library/fat16.c ****  */
  61:../Library/fat16.c **** 
  62:../Library/fat16.c **** /**
  63:../Library/fat16.c ****  * @}
  64:../Library/fat16.c ****  */
  65:../Library/fat16.c **** 
  66:../Library/fat16.c **** #define FAT16_CLUSTER_FREE 0x0000
  67:../Library/fat16.c **** #define FAT16_CLUSTER_RESERVED_MIN (uint16_t)0xfff0
  68:../Library/fat16.c **** #define FAT16_CLUSTER_RESERVED_MAX (uint16_t)0xfff6
  69:../Library/fat16.c **** #define FAT16_CLUSTER_BAD (uint16_t)0xfff7
  70:../Library/fat16.c **** #define FAT16_CLUSTER_LAST_MIN (uint16_t)0xfff8
  71:../Library/fat16.c **** #define FAT16_CLUSTER_LAST_MAX (uint16_t)0xffff
  72:../Library/fat16.c **** 
  73:../Library/fat16.c **** #define FAT16_DIRENTRY_DELETED 0xe5
  74:../Library/fat16.c **** #define FAT16_DIRENTRY_LFNLAST (1 << 6)
  75:../Library/fat16.c **** #define FAT16_DIRENTRY_LFNSEQMASK ((1 << 6) - 1)
  76:../Library/fat16.c **** 
  77:../Library/fat16.c **** /* Each entry within the directory table has a size of 32 bytes
  78:../Library/fat16.c ****  * and either contains a 8.3 DOS-style file name or a part of a
  79:../Library/fat16.c ****  * long file name, which may consist of several directory table
  80:../Library/fat16.c ****  * entries at once.
  81:../Library/fat16.c ****  *
  82:../Library/fat16.c ****  * multi-byte integer values are stored little-endian!
  83:../Library/fat16.c ****  *
  84:../Library/fat16.c ****  * 8.3 file name entry:
  85:../Library/fat16.c ****  * ====================
  86:../Library/fat16.c ****  * offset  length  description
  87:../Library/fat16.c ****  *      0       8  name (space padded)
  88:../Library/fat16.c ****  *      8       3  extension (space padded)
  89:../Library/fat16.c ****  *     11       1  attributes (FAT16_ATTRIB_*)
  90:../Library/fat16.c ****  
  91:../Library/fat16.c ****  *     0x0E     2  Creation Time
  92:../Library/fat16.c ****  *     0x10     2  Creation Date
  93:../Library/fat16.c ****  
  94:../Library/fat16.c ****  *
  95:../Library/fat16.c ****  * long file name (lfn) entry ordering for a single file name:
  96:../Library/fat16.c ****  * ===========================================================
  97:../Library/fat16.c ****  * LFN entry n
  98:../Library/fat16.c ****  *     ...
  99:../Library/fat16.c ****  * LFN entry 2
 100:../Library/fat16.c ****  * LFN entry 1
 101:../Library/fat16.c ****  * 8.3 entry (see above)
 102:../Library/fat16.c ****  *
 103:../Library/fat16.c ****  * lfn entry:
 104:../Library/fat16.c ****  * ==========
 105:../Library/fat16.c ****  * offset  length  description
 106:../Library/fat16.c ****  *      0       1  ordinal field
 107:../Library/fat16.c ****  *      1       2  unicode character 1
 108:../Library/fat16.c ****  *      3       3  unicode character 2
 109:../Library/fat16.c ****  *      5       3  unicode character 3
 110:../Library/fat16.c ****  *      7       3  unicode character 4
 111:../Library/fat16.c ****  *      9       3  unicode character 5
 112:../Library/fat16.c ****  *     11       1  attribute (always 0x0f)
 113:../Library/fat16.c ****  *     12       1  type (reserved, always 0)
 114:../Library/fat16.c ****  *     13       1  checksum
 115:../Library/fat16.c ****  *     14       2  unicode character 6
 116:../Library/fat16.c ****  *     16       2  unicode character 7
 117:../Library/fat16.c ****  *     18       2  unicode character 8
 118:../Library/fat16.c ****  *     20       2  unicode character 9
 119:../Library/fat16.c ****  *     22       2  unicode character 10
 120:../Library/fat16.c ****  *     24       2  unicode character 11
 121:../Library/fat16.c ****  *     26       2  cluster (unused, always 0)
 122:../Library/fat16.c ****  *     28       2  unicode character 12
 123:../Library/fat16.c ****  *     30       2  unicode character 13
 124:../Library/fat16.c ****  *
 125:../Library/fat16.c ****  * The ordinal field contains a descending number, from n to 1.
 126:../Library/fat16.c ****  * For the n'th lfn entry the ordinal field is or'ed with 0x40.
 127:../Library/fat16.c ****  * For deleted lfn entries, the ordinal field is set to 0xe5.
 128:../Library/fat16.c ****  */
 129:../Library/fat16.c **** 
 130:../Library/fat16.c **** struct fat16_header_struct
 131:../Library/fat16.c **** {
 132:../Library/fat16.c ****     uint32_t size;
 133:../Library/fat16.c **** 
 134:../Library/fat16.c ****     uint32_t fat_offset;
 135:../Library/fat16.c ****     uint32_t fat_size;
 136:../Library/fat16.c **** 
 137:../Library/fat16.c ****     uint16_t sector_size;
 138:../Library/fat16.c ****     uint16_t cluster_size;
 139:../Library/fat16.c **** 
 140:../Library/fat16.c ****     uint32_t root_dir_offset;
 141:../Library/fat16.c **** 
 142:../Library/fat16.c ****     uint32_t cluster_zero_offset;
 143:../Library/fat16.c **** };
 144:../Library/fat16.c **** 
 145:../Library/fat16.c **** struct fat16_fs_struct
 146:../Library/fat16.c **** {
 147:../Library/fat16.c ****     struct partition_struct* partition;
 148:../Library/fat16.c ****     struct fat16_header_struct header;
 149:../Library/fat16.c **** };
 150:../Library/fat16.c **** 
 151:../Library/fat16.c **** struct fat16_file_struct
 152:../Library/fat16.c **** {
 153:../Library/fat16.c ****     struct fat16_fs_struct* fs;
 154:../Library/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 155:../Library/fat16.c ****     uint32_t pos;
 156:../Library/fat16.c ****     uint16_t pos_cluster;
 157:../Library/fat16.c **** };
 158:../Library/fat16.c **** 
 159:../Library/fat16.c **** struct fat16_dir_struct
 160:../Library/fat16.c **** {
 161:../Library/fat16.c ****     struct fat16_fs_struct* fs;
 162:../Library/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 163:../Library/fat16.c ****     uint16_t entry_next;
 164:../Library/fat16.c **** };
 165:../Library/fat16.c **** 
 166:../Library/fat16.c **** struct fat16_read_callback_arg
 167:../Library/fat16.c **** {
 168:../Library/fat16.c ****     uint16_t entry_cur;
 169:../Library/fat16.c ****     uint16_t entry_num;
 170:../Library/fat16.c ****     uint32_t entry_offset;
 171:../Library/fat16.c ****     uint8_t byte_count;
 172:../Library/fat16.c **** };
 173:../Library/fat16.c **** 
 174:../Library/fat16.c **** struct fat16_usage_count_callback_arg
 175:../Library/fat16.c **** {
 176:../Library/fat16.c ****     uint16_t cluster_count;
 177:../Library/fat16.c ****     uint8_t buffer_size;
 178:../Library/fat16.c **** };
 179:../Library/fat16.c **** 
 180:../Library/fat16.c **** static uint8_t fat16_read_header(struct fat16_fs_struct* fs);
 181:../Library/fat16.c **** static uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, stru
 182:../Library/fat16.c **** static uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const
 183:../Library/fat16.c **** static uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p);
 184:../Library/fat16.c **** static uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p);
 185:../Library/fat16.c **** static uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* r
 186:../Library/fat16.c **** static uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 187:../Library/fat16.c **** static uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint1
 188:../Library/fat16.c **** static uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 189:../Library/fat16.c **** static uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 190:../Library/fat16.c **** static uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry
 191:../Library/fat16.c **** 
 192:../Library/fat16.c **** static uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p);
 193:../Library/fat16.c **** 
 194:../Library/fat16.c **** /**
 195:../Library/fat16.c ****  * \ingroup fat16_fs
 196:../Library/fat16.c ****  * Opens a FAT16 filesystem.
 197:../Library/fat16.c ****  *
 198:../Library/fat16.c ****  * \param[in] partition Discriptor of partition on which the filesystem resides.
 199:../Library/fat16.c ****  * \returns 0 on error, a FAT16 filesystem descriptor on success.
 200:../Library/fat16.c ****  * \see fat16_open
 201:../Library/fat16.c ****  */
 202:../Library/fat16.c **** struct fat16_fs_struct* fat16_open(struct partition_struct* partition)
 203:../Library/fat16.c **** {
 204:../Library/fat16.c ****     if(!partition ||
 205:../Library/fat16.c ****         #if FAT16_WRITE_SUPPORT
 206:../Library/fat16.c ****         !partition->device_write
 207:../Library/fat16.c ****        #else
 208:../Library/fat16.c ****         0
 209:../Library/fat16.c ****        #endif
 210:../Library/fat16.c ****        )
 211:../Library/fat16.c ****     return 0;
 212:../Library/fat16.c **** 
 213:../Library/fat16.c ****     struct fat16_fs_struct* fs = malloc(sizeof(*fs));
 214:../Library/fat16.c ****     if(!fs)
 215:../Library/fat16.c ****     {
 216:../Library/fat16.c ****         rprintf("MALLOC FAILS\n\r");
 217:../Library/fat16.c ****         return 0;
 218:../Library/fat16.c ****     }
 219:../Library/fat16.c ****     memset(fs, 0, sizeof(*fs));
 220:../Library/fat16.c **** 
 221:../Library/fat16.c ****     fs->partition = partition;
 222:../Library/fat16.c ****     if(!fat16_read_header(fs))
 223:../Library/fat16.c ****     {
 224:../Library/fat16.c ****         rprintf("Failed Reading Header\n\r");
 225:../Library/fat16.c ****         free(fs);
 226:../Library/fat16.c ****         return 0;
 227:../Library/fat16.c ****     }
 228:../Library/fat16.c **** 
 229:../Library/fat16.c ****     return fs;
 230:../Library/fat16.c **** }
 231:../Library/fat16.c **** 
 232:../Library/fat16.c **** /**
 233:../Library/fat16.c ****  * \ingroup fat16_fs
 234:../Library/fat16.c ****  * Closes a FAT16 filesystem.
 235:../Library/fat16.c ****  *
 236:../Library/fat16.c ****  * When this function returns, the given filesystem descriptor
 237:../Library/fat16.c ****  * will be invalid.
 238:../Library/fat16.c ****  *
 239:../Library/fat16.c ****  * \param[in] fs The filesystem to close.
 240:../Library/fat16.c ****  * \see fat16_open
 241:../Library/fat16.c ****  */
 242:../Library/fat16.c **** void fat16_close(struct fat16_fs_struct* fs)
 243:../Library/fat16.c **** {
 244:../Library/fat16.c ****     if(!fs)
 245:../Library/fat16.c ****         return;
 246:../Library/fat16.c **** 
 247:../Library/fat16.c ****     free(fs);
 248:../Library/fat16.c **** }
 249:../Library/fat16.c **** 
 250:../Library/fat16.c **** /**
 251:../Library/fat16.c ****  * \ingroup fat16_fs
 252:../Library/fat16.c ****  * Reads and parses the header of a FAT16 filesystem.
 253:../Library/fat16.c ****  *
 254:../Library/fat16.c ****  * \param[inout] fs The filesystem for which to parse the header.
 255:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
 256:../Library/fat16.c ****  */
 257:../Library/fat16.c **** uint8_t fat16_read_header(struct fat16_fs_struct* fs)
 258:../Library/fat16.c **** {
 259:../Library/fat16.c ****     if(!fs)
 260:../Library/fat16.c ****         return 0;
 261:../Library/fat16.c **** 
 262:../Library/fat16.c ****     struct partition_struct* partition = fs->partition;
 263:../Library/fat16.c ****     if(!partition)
 264:../Library/fat16.c ****     {
 265:../Library/fat16.c ****         rprintf("Partition = 0\n\r");
 266:../Library/fat16.c ****         return 0;
 267:../Library/fat16.c ****     }
 268:../Library/fat16.c **** 
 269:../Library/fat16.c ****     /* read fat parameters */
 270:../Library/fat16.c ****     uint8_t buffer[25];
 271:../Library/fat16.c ****     uint32_t partition_offset = partition->offset * 512;
 272:../Library/fat16.c **** 
 273:../Library/fat16.c ****     if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
 274:../Library/fat16.c ****         return 0;
 275:../Library/fat16.c **** 
 276:../Library/fat16.c ****     uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
 277:../Library/fat16.c ****     ((uint16_t) buffer[0x01] << 8);
 278:../Library/fat16.c ****     uint8_t sectors_per_cluster = buffer[0x02];
 279:../Library/fat16.c ****     uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
 280:../Library/fat16.c ****     ((uint16_t) buffer[0x04] << 8);
 281:../Library/fat16.c ****     uint8_t fat_copies = buffer[0x05];
 282:../Library/fat16.c ****     uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
 283:../Library/fat16.c ****     ((uint16_t) buffer[0x07] << 8);
 284:../Library/fat16.c ****     uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
 285:../Library/fat16.c ****     ((uint16_t) buffer[0x09] << 8);
 286:../Library/fat16.c ****     uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
 287:../Library/fat16.c ****     ((uint16_t) buffer[0x0c] << 8);
 288:../Library/fat16.c ****     uint32_t sector_count = ((uint32_t) buffer[0x15]) |
 289:../Library/fat16.c ****     ((uint32_t) buffer[0x16] << 8) |
 290:../Library/fat16.c ****     ((uint32_t) buffer[0x17] << 16) |
 291:../Library/fat16.c ****     ((uint32_t) buffer[0x18] << 24);
 292:../Library/fat16.c **** 
 293:../Library/fat16.c ****     if(sectors_per_fat == 0)
 294:../Library/fat16.c ****     /* this is not a FAT16 */
 295:../Library/fat16.c ****         return 0;
 296:../Library/fat16.c **** 
 297:../Library/fat16.c ****     if(sector_count == 0)
 298:../Library/fat16.c ****     {
 299:../Library/fat16.c ****         if(sector_count_16 == 0)
 300:../Library/fat16.c ****     /* illegal volume size */
 301:../Library/fat16.c ****             return 0;
 302:../Library/fat16.c ****         else
 303:../Library/fat16.c ****             sector_count = sector_count_16;
 304:../Library/fat16.c ****     }
 305:../Library/fat16.c **** 
 306:../Library/fat16.c ****     /* ensure we really have a FAT16 fs here */
 307:../Library/fat16.c ****     uint32_t data_sector_count = sector_count
 308:../Library/fat16.c ****     - reserved_sectors
 309:../Library/fat16.c ****     - (uint32_t) sectors_per_fat * fat_copies
 310:../Library/fat16.c ****     - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
 311:../Library/fat16.c ****     uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
 312:../Library/fat16.c ****     if(data_cluster_count < 4085 || data_cluster_count >= 65525)
 313:../Library/fat16.c ****     /* this is not a FAT16 */
 314:../Library/fat16.c ****         return 0;
 315:../Library/fat16.c **** 
 316:../Library/fat16.c ****     partition->type = PARTITION_TYPE_FAT16;
 317:../Library/fat16.c **** 
 318:../Library/fat16.c ****     /* fill header information */
 319:../Library/fat16.c ****     struct fat16_header_struct* header = &fs->header;
 320:../Library/fat16.c ****     memset(header, 0, sizeof(*header));
 321:../Library/fat16.c **** 
 322:../Library/fat16.c ****     header->size = sector_count * bytes_per_sector;
 323:../Library/fat16.c **** 
 324:../Library/fat16.c ****     header->fat_offset = /* jump to partition */
 325:../Library/fat16.c ****     partition_offset +
 326:../Library/fat16.c ****     /* jump to fat */
 327:../Library/fat16.c ****     (uint32_t) reserved_sectors * bytes_per_sector;
 328:../Library/fat16.c ****     header->fat_size = (data_cluster_count + 2) * 2;
 329:../Library/fat16.c **** 
 330:../Library/fat16.c ****     header->sector_size = bytes_per_sector;
 331:../Library/fat16.c ****     header->cluster_size = (uint32_t) bytes_per_sector * sectors_per_cluster;
 332:../Library/fat16.c **** 
 333:../Library/fat16.c ****     header->root_dir_offset = /* jump to fats */
 334:../Library/fat16.c ****     header->fat_offset +
 335:../Library/fat16.c ****     /* jump to root directory entries */
 336:../Library/fat16.c ****     (uint32_t) fat_copies * sectors_per_fat * bytes_per_sector;
 337:../Library/fat16.c **** 
 338:../Library/fat16.c ****     header->cluster_zero_offset = /* jump to root directory entries */
 339:../Library/fat16.c ****     header->root_dir_offset +
 340:../Library/fat16.c ****     /* skip root directory entries */
 341:../Library/fat16.c ****     (uint32_t) max_root_entries * 32;
 342:../Library/fat16.c **** 
 343:../Library/fat16.c ****     return 1;
 344:../Library/fat16.c **** }
 345:../Library/fat16.c **** 
 346:../Library/fat16.c **** /**
 347:../Library/fat16.c ****  * \ingroup fat16_fs
 348:../Library/fat16.c ****  * Reads a directory entry of the root directory.
 349:../Library/fat16.c ****  *
 350:../Library/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 351:../Library/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 352:../Library/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 353:../Library/fat16.c ****  * \returns 0 on failure, 1 on success
 354:../Library/fat16.c ****  * \see fat16_read_sub_dir_entry, fat16_read_dir_entry_by_path
 355:../Library/fat16.c ****  */
 356:../Library/fat16.c **** uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, struct fat1
 357:../Library/fat16.c **** {
 358:../Library/fat16.c ****     if(!fs || !dir_entry)
 359:../Library/fat16.c ****         return 0;
 360:../Library/fat16.c **** 
 361:../Library/fat16.c ****     /* we read from the root directory entry */
 362:../Library/fat16.c ****     const struct fat16_header_struct* header = &fs->header;
 363:../Library/fat16.c ****     device_read_interval_t device_read_interval = fs->partition->device_read_interval;
 364:../Library/fat16.c ****     uint8_t buffer[32];
 365:../Library/fat16.c **** 
 366:../Library/fat16.c ****     /* seek to the n-th entry */
 367:../Library/fat16.c ****     struct fat16_read_callback_arg arg;
 368:../Library/fat16.c ****     memset(&arg, 0, sizeof(arg));
 369:../Library/fat16.c ****     arg.entry_num = entry_num;
 370:../Library/fat16.c ****     if(!device_read_interval(header->root_dir_offset,
 371:../Library/fat16.c ****         buffer,
 372:../Library/fat16.c ****        sizeof(buffer),
 373:../Library/fat16.c ****        header->cluster_zero_offset - header->root_dir_offset,
 374:../Library/fat16.c ****        fat16_dir_entry_seek_callback,
 375:../Library/fat16.c ****        &arg) ||
 376:../Library/fat16.c ****        arg.entry_offset == 0
 377:../Library/fat16.c ****        )
 378:../Library/fat16.c ****     return 0;
 379:../Library/fat16.c **** 
 380:../Library/fat16.c ****     /* read entry */
 381:../Library/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 382:../Library/fat16.c ****     if(!device_read_interval(arg.entry_offset,
 383:../Library/fat16.c ****         buffer,
 384:../Library/fat16.c ****        sizeof(buffer),
 385:../Library/fat16.c ****        arg.byte_count,
 386:../Library/fat16.c ****        fat16_dir_entry_read_callback,
 387:../Library/fat16.c ****        dir_entry))
 388:../Library/fat16.c ****     return 0;
 389:../Library/fat16.c **** 
 390:../Library/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 391:../Library/fat16.c **** }
 392:../Library/fat16.c **** 
 393:../Library/fat16.c **** /**
 394:../Library/fat16.c ****  * \ingroup fat16_fs
 395:../Library/fat16.c ****  * Reads a directory entry of a given parent directory.
 396:../Library/fat16.c ****  *
 397:../Library/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 398:../Library/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 399:../Library/fat16.c ****  * \param[in] parent Directory entry descriptor in which to read directory entry.
 400:../Library/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 401:../Library/fat16.c ****  * \returns 0 on failure, 1 on success
 402:../Library/fat16.c ****  * \see fat16_read_root_dir_entry, fat16_read_dir_entry_by_path
 403:../Library/fat16.c ****  */
 404:../Library/fat16.c **** uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const struct
 405:../Library/fat16.c **** {
 406:../Library/fat16.c ****     if(!fs || !parent || !dir_entry)
 407:../Library/fat16.c ****         return 0;
 408:../Library/fat16.c **** 
 409:../Library/fat16.c ****     /* we are in a parent directory and want to search within its directory entry table */
 410:../Library/fat16.c ****     if(!(parent->attributes & FAT16_ATTRIB_DIR))
 411:../Library/fat16.c ****         return 0;
 412:../Library/fat16.c **** 
 413:../Library/fat16.c ****     /* loop through all clusters of the directory */
 414:../Library/fat16.c ****     uint8_t buffer[32];
 415:../Library/fat16.c ****     uint32_t cluster_offset;
 416:../Library/fat16.c ****     uint16_t cluster_size = fs->header.cluster_size;
 417:../Library/fat16.c ****     uint16_t cluster_num = parent->cluster;
 418:../Library/fat16.c ****     struct fat16_read_callback_arg arg;
 419:../Library/fat16.c **** 
 420:../Library/fat16.c ****     while(1)
 421:../Library/fat16.c ****     {
 422:../Library/fat16.c ****         /* calculate new cluster offset */
 423:../Library/fat16.c ****         cluster_offset = fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * cluster_si
 424:../Library/fat16.c **** 
 425:../Library/fat16.c ****         /* seek to the n-th entry */
 426:../Library/fat16.c ****         memset(&arg, 0, sizeof(arg));
 427:../Library/fat16.c ****         arg.entry_num = entry_num;
 428:../Library/fat16.c ****         if(!fs->partition->device_read_interval(cluster_offset,
 429:../Library/fat16.c ****             buffer,
 430:../Library/fat16.c ****            sizeof(buffer),
 431:../Library/fat16.c ****            cluster_size,
 432:../Library/fat16.c ****            fat16_dir_entry_seek_callback,
 433:../Library/fat16.c ****            &arg)
 434:../Library/fat16.c ****            )
 435:../Library/fat16.c ****         return 0;
 436:../Library/fat16.c **** 
 437:../Library/fat16.c ****         /* check if we found the entry */
 438:../Library/fat16.c ****         if(arg.entry_offset)
 439:../Library/fat16.c ****             break;
 440:../Library/fat16.c **** 
 441:../Library/fat16.c ****         /* get number of next cluster */
 442:../Library/fat16.c ****         if(!(cluster_num = fat16_get_next_cluster(fs, cluster_num)))
 443:../Library/fat16.c ****             return 0; /* directory entry not found */
 444:../Library/fat16.c ****     }
 445:../Library/fat16.c **** 
 446:../Library/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 447:../Library/fat16.c **** 
 448:../Library/fat16.c ****     /* read entry */
 449:../Library/fat16.c ****     if(!fs->partition->device_read_interval(arg.entry_offset,
 450:../Library/fat16.c ****         buffer,
 451:../Library/fat16.c ****        sizeof(buffer),
 452:../Library/fat16.c ****        arg.byte_count,
 453:../Library/fat16.c ****        fat16_dir_entry_read_callback,
 454:../Library/fat16.c ****        dir_entry))
 455:../Library/fat16.c ****     return 0;
 456:../Library/fat16.c **** 
 457:../Library/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 458:../Library/fat16.c **** }
 459:../Library/fat16.c **** 
 460:../Library/fat16.c **** /**
 461:../Library/fat16.c ****  * \ingroup fat16_fs
 462:../Library/fat16.c ****  * Callback function for seeking through subdirectory entries.
 463:../Library/fat16.c ****  */
 464:../Library/fat16.c **** uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p)
 465:../Library/fat16.c **** {
  15              		@ Function supports interworking.
  16              		@ args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		.loc 1 469 0
 466:../Library/fat16.c **** ;
 467:../Library/fat16.c **** 
 468:../Library/fat16.c ****     /* skip deleted or empty entries */
 469:../Library/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
  21              	r3, [r0, #0]	@ zero_extendqisi2
  22 0000 0030D0E5 		cmp	r3, #0
  23 0004 000053E3 		cmpne	r3, #229
  24 0008 E5005313 		.loc 1 465 0
  25              		@ lr needed for prologue
  26              		.loc 1 469 0
  27              		beq	.L2
  28 000c 1500000A 		.loc 1 472 0
 470:../Library/fat16.c ****     return 1;
 471:../Library/fat16.c **** 
 472:../Library/fat16.c ****     if(arg->entry_cur == arg->entry_num)
  29              	, [r2, #0]
  30 0010 B0C0D2E1 		ldrh	r3, [r2, #2]
  31 0014 B230D2E1 		cmp	r3, ip
  32 0018 0C0053E1 		bne	.L4
  33 001c 0B00001A 		.loc 1 474 0
 473:../Library/fat16.c ****  {
 474:../Library/fat16.c ****         arg->entry_offset = offset;
  34              	r1, [r2, #4]
  35 0020 041082E5 		.loc 1 475 0
 475:../Library/fat16.c ****       arg->byte_count = buffer[11] == 0x0f ?
  36              	drb	r3, [r0, #11]	@ zero_extendqisi2
  37 0024 0B30D0E5 		cmp	r3, #15
  38 0028 0F0053E3 		ldreqb	r3, [r0, #0]	@ zero_extendqisi2
  39 002c 0030D005 		andeq	r3, r3, #63
  40 0030 3F300302 		moveq	r3, r3, asl #5
  41 0034 8332A001 		addeq	r3, r3, #32
  42 0038 20308302 		mov	r1, #32
  43 003c 2010A0E3 	.LVL1:
  44              		mov	r0, #0
  45 0040 0000A0E3 	.LVL2:
  46              		andeq	r1, r3, #255
  47 0044 FF100302 		strb	r1, [r2, #8]
  48 0048 0810C2E5 		bx	lr
  49 004c 1EFF2FE1 	.LVL3:
  50              	.L4:
  51              		.loc 1 482 0
 476:../Library/fat16.c ****        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
 477:../Library/fat16.c ****         32;
 478:../Library/fat16.c ****         return 0;
 479:../Library/fat16.c ****     }
 480:../Library/fat16.c **** 
 481:../Library/fat16.c ****     /* if we read a 8.3 entry, we reached a new directory entry */
 482:../Library/fat16.c ****     if(buffer[11] != 0x0f)
  52              	11]	@ zero_extendqisi2
  53 0050 0B30D0E5 		.loc 1 483 0
 483:../Library/fat16.c ****  ++arg->entry_cur;
  54              	dd	r1, ip, #1
  55 0054 01108CE2 	.LVL4:
  56              		.loc 1 482 0
  57              		cmp	r3, #15
  58 0058 0F0053E3 		.loc 1 483 0
  59              		mov	r0, #1
  60 005c 0100A0E3 	.LVL5:
  61              		strneh	r1, [r2, #0]	@ movhi
  62 0060 B010C211 		.loc 1 482 0
  63              		bxne	lr
  64 0064 1EFF2F11 	.LVL6:
  65              	.L2:
  66              		.loc 1 483 0
  67              		mov	r0, #1
  68 0068 0100A0E3 	.LVL7:
  69              		.loc 1 486 0
 484:../Library/fat16.c ****     return 1;
 485:../Library/fat16.c **** }
 486:../Library/fat16.c **** 
  70              	size	fat16_dir_entry_seek_callback, .-fat16_dir_entry_seek_callback
  71 006c 1EFF2FE1 		.align	2
  73              	fat16_dir_entry_read_callback:
  74              	.LFB8:
  75              		.loc 1 493 0
  76              		@ Function supports interworking.
  77              		@ args = 0, pretend = 0, frame = 0
 487:../Library/fat16.c **** 
 488:../Library/fat16.c ****  * \ingroup fat16_fs
 489:../Library/fat16.c ****  * Callback function for reading a directory entry.
 490:../Library/fat16.c ****  */
 491:../Library/fat16.c **** uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
 492:../Library/fat16.c **** {
 493:../Library/fat16.c ****     struct fat16_dir_entry_struct* dir_entry = p;
  78              	_needed = 0, uses_anonymous_args = 0
  79              	.LVL8:
  80              		stmfd	sp!, {r4, r5, lr}
  81              	.LCFI0:
  82              		.loc 1 497 0
  83 0070 30402DE9 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  84              		cmp	r3, #0
 494:../Library/fat16.c **** * there should not be any deleted or empty entries */
 495:../Library/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
 496:../Library/fat16.c ****         return 0;
 497:../Library/fat16.c **** 
  85              	r3, #229
  86 0074 0030D0E5 		.loc 1 493 0
  87 0078 000053E3 		mov	ip, r2
  88 007c E5005313 		.loc 1 497 0
  89              		beq	.L13
  90 0080 02C0A0E1 	.LVL9:
  91              		.loc 1 500 0
  92 0084 6200000A 		ldr	r3, [r2, #40]
  93              		cmp	r3, #0
 498:../Library/fat16.c **** if(!dir_entry->entry_offset)
 499:../Library/fat16.c ****         dir_entry->entry_offset = offset;
 500:../Library/fat16.c **** 
  94              	01 0
  95 0088 283092E5 		streq	r1, [r2, #40]
  96 008c 000053E3 	.LBB9:
 501:../Library/fat16.c ****  switch(fat16_interpret_dir_entry(dir_entry, buffer))
  97              	B10:
  98 0090 28108205 		.loc 1 534 0
  99              		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 100              		cmp	r2, #0
 502:../Library/fat16.c ****    {
 503:../Library/fat16.c ****         case 0: /* failure */
 504:../Library/fat16.c ****             return 0;
 505:../Library/fat16.c ****             case 1: /* buffer successfully parsed, continue */
 506:../Library/fat16.c ****             return 1;
 507:../Library/fat16.c ****             case 2: /* directory entry complete, finish */
 508:../Library/fat16.c ****             return 0;
 509:../Library/fat16.c ****         }
 510:../Library/fat16.c **** 
 511:../Library/fat16.c ****     return 0;
 512:../Library/fat16.c **** }
 513:../Library/fat16.c **** 
 514:../Library/fat16.c **** /**
 515:../Library/fat16.c ****  * \ingroup fat16_fs
 516:../Library/fat16.c ****  * Interprets a raw directory entry and puts the contained
 517:../Library/fat16.c ****  * information into the directory entry.
 518:../Library/fat16.c ****  *
 519:../Library/fat16.c ****  * For a single file there may exist multiple directory
 520:../Library/fat16.c ****  * entries. All except the last one are lfn entries, which
 521:../Library/fat16.c ****  * contain parts of the long filename. The last directory
 522:../Library/fat16.c ****  * entry is a traditional 8.3 style one. It contains all
 523:../Library/fat16.c ****  * other information like size, cluster, date and time.
 524:../Library/fat16.c ****  *
 525:../Library/fat16.c ****  * \param[in,out] dir_entry The directory entry to fill.
 526:../Library/fat16.c ****  * \param[in] raw_entry A pointer to 32 bytes of raw data.
 527:../Library/fat16.c ****  * \returns 0 on failure, 1 on success and 2 if the
 528:../Library/fat16.c ****  *          directory entry is complete.
 529:../Library/fat16.c ****  */
 530:../Library/fat16.c **** uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entr
 531:../Library/fat16.c **** {
 532:../Library/fat16.c ****     if(!dir_entry || !raw_entry || !raw_entry[0])
 533:../Library/fat16.c ****         return 0;
 534:../Library/fat16.c **** 
 101              		.L13
 102 0094 0020D0E5 		.loc 1 538 0
 103 0098 000052E3 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 104 009c 5C00000A 		cmp	r3, #15
 535:../Library/fat16.c **** long_name;
 536:../Library/fat16.c ****     if(raw_entry[11] == 0x0f)
 537:../Library/fat16.c ****     {
 538:../Library/fat16.c ****         uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
 105              		r5, r0, #11
 106 00a0 0B30D0E5 		bne	.L18
 107 00a4 0F0053E3 	.LBB11:
 108 00a8 0B5080E2 		.loc 1 540 0
 109 00ac 2600001A 		and	r2, r2, #63
 110              		mov	r3, #13
 539:../Library/fat16.c ****      if(char_offset + 12 < sizeof(dir_entry->long_name))
 540:../Library/fat16.c ****         {
 111              	3, r2, r3
 112 00b0 3F2002E2 		sub	r3, r3, #13
 113 00b4 0D30A0E3 		mov	r3, r3, asl #16
 114 00b8 920303E0 		mov	r2, r3, lsr #16
 115 00bc 0D3043E2 	.LVL10:
 116 00c0 0338A0E1 		.loc 1 542 0
 117 00c4 2328A0E1 		add	r3, r2, #12
 118              		cmp	r3, #31
 541:../Library/fat16.c ****           /* Lfn supports unicode, but we do not, for now.
 542:../Library/fat16.c ****                                                  * So we assume pure ascii and read only every
 119              	0, #1
 120 00c8 0C3082E2 	.LVL11:
 121 00cc 1F0053E3 		bhi	.L22
 122 00d0 0100A083 	.LVL12:
 123              		.loc 1 548 0
 124 00d4 4F00008A 		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 125              		strb	r3, [ip, r2]
 543:../Library/fat16.c ****                                                * second byte.
 544:../Library/fat16.c ****                                                  */
 545:../Library/fat16.c ****             long_name[char_offset + 0] = raw_entry[1];
 546:../Library/fat16.c ****             long_name[char_offset + 1] = raw_entry[3];
 547:../Library/fat16.c ****             long_name[char_offset + 2] = raw_entry[5];
 548:../Library/fat16.c ****             long_name[char_offset + 3] = raw_entry[7];
 126              	 549 0
 127 00d8 0130D0E5 		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 128 00dc 0230CCE7 		add	r2, ip, r2
 549:../Library/fat16.c ****       long_name[char_offset + 4] = raw_entry[9];
 129              	L13:
 130 00e0 0330D0E5 		strb	r3, [r2, #1]
 131 00e4 02208CE0 		.loc 1 550 0
 132              		ldrb	r3, [r0, #5]	@ zero_extendqisi2
 133 00e8 0130C2E5 		strb	r3, [r2, #2]
 550:../Library/fat16.c ****            long_name[char_offset + 5] = raw_entry[14];
 134              	 1 551 0
 135 00ec 0530D0E5 		ldrb	r3, [r0, #7]	@ zero_extendqisi2
 136 00f0 0230C2E5 		strb	r3, [r2, #3]
 551:../Library/fat16.c ****            long_name[char_offset + 6] = raw_entry[16];
 137              	oc 1 552 0
 138 00f4 0730D0E5 		ldrb	r3, [r0, #9]	@ zero_extendqisi2
 139 00f8 0330C2E5 		strb	r3, [r2, #4]
 552:../Library/fat16.c ****            long_name[char_offset + 7] = raw_entry[18];
 140              	oc 1 553 0
 141 00fc 0930D0E5 		ldrb	r3, [r0, #14]	@ zero_extendqisi2
 142 0100 0430C2E5 		strb	r3, [r2, #5]
 553:../Library/fat16.c ****            long_name[char_offset + 8] = raw_entry[20];
 143              	oc 1 554 0
 144 0104 0E30D0E5 		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 145 0108 0530C2E5 		strb	r3, [r2, #6]
 554:../Library/fat16.c ****            long_name[char_offset + 9] = raw_entry[22];
 146              	oc 1 555 0
 147 010c 1030D0E5 		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 148 0110 0630C2E5 		strb	r3, [r2, #7]
 555:../Library/fat16.c ****            long_name[char_offset + 10] = raw_entry[24];
 149              	oc 1 556 0
 150 0114 1230D0E5 		ldrb	r3, [r0, #20]	@ zero_extendqisi2
 151 0118 0730C2E5 		strb	r3, [r2, #8]
 556:../Library/fat16.c ****            long_name[char_offset + 11] = raw_entry[28];
 152              	oc 1 557 0
 153 011c 1430D0E5 		ldrb	r3, [r0, #22]	@ zero_extendqisi2
 154 0120 0830C2E5 		strb	r3, [r2, #9]
 557:../Library/fat16.c ****            long_name[char_offset + 12] = raw_entry[30];
 155              	oc 1 558 0
 156 0124 1630D0E5 		ldrb	r3, [r0, #24]	@ zero_extendqisi2
 157 0128 0930C2E5 		strb	r3, [r2, #10]
 558:../Library/fat16.c ****        }
 158              	oc 1 559 0
 159 012c 1830D0E5 		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 160 0130 0A30C2E5 		strb	r3, [r2, #11]
 559:../Library/fat16.c ****         return 1;
 161              	oc 1 560 0
 162 0134 1C30D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 163 0138 0B30C2E5 		mov	r0, #1
 560:../Library/fat16.c ****    }
 164              	L14:
 165 013c 1E30D0E5 		strb	r3, [r2, #12]
 166 0140 0100A0E3 		b	.L22
 167              	.LVL15:
 168 0144 0C30C2E5 	.L18:
 169 0148 320000EA 	.LBE11:
 170              		.loc 1 568 0
 171              		ldrb	r2, [ip, #0]	@ zero_extendqisi2
 172              		cmp	r2, #0
 561:../Library/fat16.c ****    else
 562:../Library/fat16.c ****     {
 563:../Library/fat16.c ****         /* if we do not have a long name, take the short one */
 564:../Library/fat16.c ****         if(long_name[0] == '\0')
 565:../Library/fat16.c ****         {
 566:../Library/fat16.c ****             uint8_t i;
 567:../Library/fat16.c ****             for(i = 0; i < 8; ++i)
 568:../Library/fat16.c ****             {
 173              	
 174 014c 0020DCE5 		mov	r1, r2
 175 0150 000052E3 	.LVL16:
 176 0154 1D00001A 	.L25:
 177 0158 0210A0E1 	.LBB12:
 178              		.loc 1 573 0
 179              		ldrb	r3, [r2, r0]	@ zero_extendqisi2
 180              		cmp	r3, #32
 569:../Library/fat16.c ****         if(raw_entry[i] == ' ')
 570:../Library/fat16.c ****                     break;
 571:../Library/fat16.c ****                 long_name[i] = raw_entry[i];
 572:../Library/fat16.c ****             }
 573:../Library/fat16.c ****             if(raw_entry[8] != ' ')
 181              	 571 0
 182 015c 0030D2E7 		add	lr, r1, #1
 183 0160 200053E3 		.loc 1 573 0
 184              		beq	.L26
 185 0164 01E081E2 		.loc 1 571 0
 186              		and	r1, lr, #255
 187 0168 0400000A 		cmp	r1, #8
 188              		.loc 1 575 0
 189 016c FF100EE2 		strb	r3, [r2, ip]
 190 0170 080051E3 		.loc 1 571 0
 574:../Library/fat16.c ****        {
 575:../Library/fat16.c ****                 long_name[i++] = '.';
 191              	2, #1
 192 0174 0C30C2E7 		bne	.L25
 193              	.L26:
 194 0178 012082E2 		.loc 1 577 0
 195 017c F6FFFF1A 		ldrb	r3, [r0, #8]	@ zero_extendqisi2
 196              		cmp	r3, #32
 576:../Library/fat16.c ****                uint8_t j = 8;
 577:../Library/fat16.c ****                 for(; j < 11; ++j)
 197              	L28
 198 0180 0830D0E5 	.LBB13:
 199 0184 200053E3 		.loc 1 579 0
 200 0188 0E00000A 		mov	r3, #46
 201              		add	r2, r1, #1
 578:../Library/fat16.c ****               {
 579:../Library/fat16.c ****                     if(raw_entry[j] != ' ')
 202              		r3, [ip, r1]
 203 018c 2E30A0E3 		and	r1, r2, #255
 204 0190 012081E2 		mov	r3, r0
 205 0194 0130CCE7 	.L30:
 206 0198 FF1002E2 		.loc 1 584 0
 207 019c 0030A0E1 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 208              		cmp	r2, #32
 580:../Library/fat16.c ****                   {
 581:../Library/fat16.c ****                         long_name[i++] = raw_entry[j];
 582:../Library/fat16.c ****                     }
 583:../Library/fat16.c ****                     else
 584:../Library/fat16.c ****                     {
 209              	 582 0
 210 01a0 0820D3E5 		add	lr, r0, #3
 211 01a4 200052E3 		.loc 1 586 0
 212              		add	r4, r1, #1
 213 01a8 03E080E2 		add	r3, r3, #1
 585:../Library/fat16.c ****                    break;
 586:../Library/fat16.c ****                     }
 214              	 1 584 0
 215 01ac 014081E2 		beq	.L28
 216 01b0 013083E2 		.loc 1 582 0
 217              		cmp	r3, lr
 218 01b4 0300000A 		.loc 1 586 0
 219              		strb	r2, [ip, r1]
 220 01b8 0E0053E1 		and	r1, r4, #255
 221              		.loc 1 582 0
 222 01bc 0120CCE7 		bne	.L30
 223 01c0 FF1004E2 	.L28:
 224              	.LBE13:
 225 01c4 F5FFFF1A 		.loc 1 595 0
 226              		mov	r3, #0
 227              		strb	r3, [ip, r1]
 587:../Library/fat16.c ****               }
 588:../Library/fat16.c ****             }
 589:../Library/fat16.c **** 
 590:../Library/fat16.c ****             long_name[i] = '\0';
 591:../Library/fat16.c ****         }
 592:../Library/fat16.c **** 
 593:../Library/fat16.c ****         /* extract properties of file and store them within the structure */
 594:../Library/fat16.c ****         dir_entry->attributes = raw_entry[11];
 595:../Library/fat16.c ****         dir_entry->cluster = ((uint16_t) raw_entry[26]) |
 228              	.LBE12:
 229 01c8 0030A0E3 		.loc 1 599 0
 230 01cc 0130CCE7 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 231              		strb	r3, [ip, #32]
 232              		.loc 1 600 0
 233              		ldrb	r2, [r0, #27]	@ zero_extendqisi2
 596:../Library/fat16.c **** (uint16_t) raw_entry[27] << 8);
 597:../Library/fat16.c ****         dir_entry->file_size = ((uint32_t) raw_entry[28]) |
 598:../Library/fat16.c ****         ((uint32_t) raw_entry[29] << 8) |
 599:../Library/fat16.c ****         ((uint32_t) raw_entry[30] << 16) |
 234              	r3, [r0, #26]	@ zero_extendqisi2
 235 01d0 0030D5E5 		orr	r3, r3, r2, asl #8
 236 01d4 2030CCE5 		strh	r3, [ip, #34]	@ movhi
 600:../Library/fat16.c ****     ((uint32_t) raw_entry[31] << 24);
 237              	oc 1 602 0
 238 01d8 1B20D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 239 01dc 1A30D0E5 		ldrb	r2, [r0, #28]	@ zero_extendqisi2
 240 01e0 023483E1 		ldrb	r1, [r0, #29]	@ zero_extendqisi2
 241 01e4 B232CCE1 	.LVL18:
 601:../Library/fat16.c ****         return 2;
 602:../Library/fat16.c ****     }
 242              		r0, [r0, #31]	@ zero_extendqisi2
 243 01e8 1E30D0E5 	.LVL19:
 244 01ec 1C20D0E5 		mov	r3, r3, asl #16
 245 01f0 1D10D0E5 		orr	r3, r3, r0, asl #24
 246              		orr	r2, r2, r1, asl #8
 247 01f4 1F00D0E5 		orr	r2, r2, r3
 248              		mov	r0, #0
 249 01f8 0338A0E1 		str	r2, [ip, #36]
 250 01fc 003C83E1 		b	.L22
 251 0200 012482E1 	.LVL20:
 252 0204 032082E1 	.L13:
 253 0208 0000A0E3 		mov	r0, #0
 254 020c 24208CE5 	.LVL21:
 255 0210 000000EA 	.L22:
 256              	.LBE10:
 257              	.LBE9:
 258 0214 0000A0E3 		.loc 1 514 0
 259              		ldmfd	sp!, {r4, r5, lr}
 260              		bx	lr
 261              	.LFE8:
 263              		.align	2
 265 021c 1EFF2FE1 	fat16_get_next_cluster:
 266              	.LFB11:
 267              		.loc 1 695 0
 268              		@ Function supports interworking.
 269              		@ args = 0, pretend = 0, frame = 4
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              	.LVL22:
 603:../Library/fat16.c **** 
 604:../Library/fat16.c **** /**
 605:../Library/fat16.c ****  * \ingroup fat16_file
 606:../Library/fat16.c ****  * Retrieves the directory entry of a path.
 607:../Library/fat16.c ****  *
 608:../Library/fat16.c ****  * The given path may both describe a file or a directory.
 609:../Library/fat16.c ****  *
 610:../Library/fat16.c ****  * \param[in] fs The FAT16 filesystem on which to search.
 611:../Library/fat16.c ****  * \param[in] path The path of which to read the directory entry.
 612:../Library/fat16.c ****  * \param[out] dir_entry The directory entry to fill.
 613:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
 614:../Library/fat16.c ****  * \see fat16_read_dir
 615:../Library/fat16.c ****  */
 616:../Library/fat16.c **** uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_
 617:../Library/fat16.c **** {
 618:../Library/fat16.c ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 619:../Library/fat16.c ****         return 0;
 620:../Library/fat16.c **** 
 621:../Library/fat16.c ****     if(path[0] == '/')
 622:../Library/fat16.c ****         ++path;
 623:../Library/fat16.c **** 
 624:../Library/fat16.c ****     /* begin with the root directory */
 625:../Library/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 626:../Library/fat16.c ****     dir_entry->attributes = FAT16_ATTRIB_DIR;
 627:../Library/fat16.c **** 
 628:../Library/fat16.c ****     if(path[0] == '\0')
 629:../Library/fat16.c ****         return 1;
 630:../Library/fat16.c **** 
 631:../Library/fat16.c ****     while(1)
 632:../Library/fat16.c ****     {
 633:../Library/fat16.c ****         struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
 634:../Library/fat16.c ****         if(!dd)
 635:../Library/fat16.c ****             break;
 636:../Library/fat16.c **** 
 637:../Library/fat16.c ****         /* extract the next hierarchy we will search for */
 638:../Library/fat16.c ****         const char* sep_pos = strchr(path, '/');
 639:../Library/fat16.c ****         if(!sep_pos)
 640:../Library/fat16.c ****             sep_pos = path + strlen(path);
 641:../Library/fat16.c ****         uint8_t length_to_sep = sep_pos - path;
 642:../Library/fat16.c **** 
 643:../Library/fat16.c ****         /* read directory entries */
 644:../Library/fat16.c ****         while(fat16_read_dir(dd, dir_entry))
 645:../Library/fat16.c ****         {
 646:../Library/fat16.c ****             /* check if we have found the next hierarchy */
 647:../Library/fat16.c ****             if((strlen(dir_entry->long_name) != length_to_sep ||
 648:../Library/fat16.c ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 649:../Library/fat16.c ****             continue;
 650:../Library/fat16.c **** 
 651:../Library/fat16.c ****             fat16_close_dir(dd);
 652:../Library/fat16.c ****             dd = 0;
 653:../Library/fat16.c **** 
 654:../Library/fat16.c ****             if(path[length_to_sep] == '\0')
 655:../Library/fat16.c ****     /* we iterated through the whole path and have found the file */
 656:../Library/fat16.c ****                 return 1;
 657:../Library/fat16.c **** 
 658:../Library/fat16.c ****             if(dir_entry->attributes & FAT16_ATTRIB_DIR)
 659:../Library/fat16.c ****             {
 660:../Library/fat16.c ****                 /* we found a parent directory of the file we are searching for */
 661:../Library/fat16.c ****                 path = sep_pos + 1;
 662:../Library/fat16.c ****                 break;
 663:../Library/fat16.c ****             }
 664:../Library/fat16.c **** 
 665:../Library/fat16.c ****             /* a parent of the file exists, but not the file itself */
 666:../Library/fat16.c ****             return 0;
 667:../Library/fat16.c ****         }
 668:../Library/fat16.c **** 
 669:../Library/fat16.c ****         fat16_close_dir(dd);
 670:../Library/fat16.c ****     }
 671:../Library/fat16.c **** 
 672:../Library/fat16.c ****     return 0;
 673:../Library/fat16.c **** }
 674:../Library/fat16.c **** 
 675:../Library/fat16.c **** /**
 676:../Library/fat16.c ****  * \ingroup fat16_fs
 677:../Library/fat16.c ****  * Retrieves the next following cluster of a given cluster.
 678:../Library/fat16.c ****  *
 679:../Library/fat16.c ****  * Using the filesystem file allocation table, this function returns
 680:../Library/fat16.c ****  * the number of the cluster containing the data directly following
 681:../Library/fat16.c ****  * the data within the cluster with the given number.
 682:../Library/fat16.c ****  *
 683:../Library/fat16.c ****  * \param[in] fs The filesystem for which to determine the next cluster.
 684:../Library/fat16.c ****  * \param[in] cluster_num The number of the cluster for which to determine its successor.
 685:../Library/fat16.c ****  * \returns The wanted cluster number, or 0 on error.
 686:../Library/fat16.c ****  */
 687:../Library/fat16.c **** uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 688:../Library/fat16.c **** {
 689:../Library/fat16.c ****     if(!fs || cluster_num < 2)
 690:../Library/fat16.c ****         return 0;
 691:../Library/fat16.c **** 
 692:../Library/fat16.c ****     /* read appropriate fat entry */
 693:../Library/fat16.c ****     uint8_t fat_entry[2];
 694:../Library/fat16.c ****     if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
 695:../Library/fat16.c ****         return 0;
 272              	ov	r3, r1, asl #16
 273              		mov	r3, r3, lsr #16
 274              		sub	sp, sp, #4
 275              	.LCFI2:
 276              		.loc 1 701 0
 277 0220 04E02DE5 		mov	r2, #2
 278              		.loc 1 696 0
 279 0224 0138A0E1 		cmp	r0, #0
 280 0228 2338A0E1 		cmpne	r3, #1
 281 022c 04D04DE2 		.loc 1 701 0
 282              		add	r1, sp, r2
 696:../Library/fat16.c ****  ((uint16_t) fat_entry[1] << 8);
 697:../Library/fat16.c **** 	///*
 698:../Library/fat16.c ****     if(cluster_num == FAT16_CLUSTER_FREE ||
 699:../Library/fat16.c ****         cluster_num == FAT16_CLUSTER_BAD ||
 700:../Library/fat16.c ****        (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
 701:../Library/fat16.c ****        (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 283              	oc 1 696 0
 284 0230 0220A0E3 		mov	ip, r0
 285              		bls	.L36
 286 0234 000050E3 	.LVL24:
 287 0238 01005313 		.loc 1 701 0
 288              		ldr	r0, [r0, #8]
 289 023c 02108DE0 		mla	r0, r3, r2, r0
 290              		ldr	r3, [ip, #0]
 291              	.LVL25:
 292 0240 00C0A0E1 		ldr	ip, [r3, #0]
 293 0244 1A00009A 		mov	lr, pc
 294              		bx	ip
 295              	.LVL26:
 296 0248 080090E5 		cmp	r0, #0
 297 024c 930220E0 		.loc 1 708 0
 298 0250 00309CE5 		ldr	r1, .L43
 299              		.loc 1 701 0
 300 0254 00C093E5 		beq	.L36
 301 0258 0FE0A0E1 		.loc 1 705 0
 302 025c 1CFF2FE1 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 303              		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 304 0260 000050E3 		.loc 1 708 0
 702:../Library/fat16.c **** */
 703:../Library/fat16.c **** 	return 0;
 704:../Library/fat16.c **** 
 705:../Library/fat16.c ****     return cluster_num;
 706:../Library/fat16.c **** }
 707:../Library/fat16.c **** 
 708:../Library/fat16.c **** /**
 305              	#8
 306 0264 58109FE5 	.LVL27:
 307              		movne	r3, #0
 308 0268 1100000A 		moveq	r3, #1
 309              		cmp	r0, r1
 310 026c 0220DDE5 		orreq	r3, r3, #1
 311 0270 0330DDE5 		add	r2, r0, #16
 312              		cmp	r3, #0
 313 0274 030492E1 		mov	r2, r2, asl #16
 314              		bne	.L36
 315 0278 0030A013 		cmp	r0, r1
 316 027c 0130A003 		movls	r3, #0
 317 0280 010050E1 		movhi	r3, #1
 318 0284 01308303 		cmp	r2, #393216
 319 0288 102080E2 		orrls	r3, r3, #1
 320 028c 000053E3 		cmp	r3, #0
 321 0290 0228A0E1 		beq	.L41
 322 0294 0600001A 	.LVL28:
 323 0298 010050E1 	.L36:
 324 029c 0030A093 		.loc 1 715 0
 325 02a0 0130A083 		mov	r0, #0
 326 02a4 060852E3 	.LVL29:
 327 02a8 01308393 	.L41:
 328 02ac 000053E3 	.LVL30:
 329 02b0 0000000A 		.loc 1 716 0
 330              		add	sp, sp, #4
 331              		ldr	lr, [sp], #4
 709:../Library/fat16.c **** roup fat16_fs
 710:../Library/fat16.c ****  * Appends a new cluster chain to an existing one.
 711:../Library/fat16.c ****  *
 712:../Library/fat16.c ****  * Set cluster_num to zero to create a completely new one.
 713:../Library/fat16.c ****  *
 714:../Library/fat16.c ****  * \param[in] fs The file system on which to operate.
 715:../Library/fat16.c ****  * \param[in] cluster_num The cluster to which to append the new chain.
 332              	:
 333 02b4 0000A0E3 		.word	65527
 334              	.LFE11:
 336              		.align	2
 716:../Library/fat16.c **** am[in] count The number of clusters to allocate.
 337              	e	fat16_free_clusters, %function
 338 02b8 04D08DE2 	fat16_free_clusters:
 339 02bc 04E09DE4 	.LFB13:
 340 02c0 1EFF2FE1 		.loc 1 823 0
 341              		@ Function supports interworking.
 342              		@ args = 0, pretend = 0, frame = 4
 343              		@ frame_needed = 0, uses_anonymous_args = 0
 344 02c4 F7FF0000 	.LVL31:
 345              		stmfd	sp!, {r4, r5, r6, r7, lr}
 346              	.LCFI3:
 347              		mov	r1, r1, asl #16
 348              	.LVL32:
 349              		mov	r3, r1, lsr #16
 350              	.LVL33:
 717:../Library/fat16.c **** * \returns 0 on failure, the number of the first new cluster on success.
 718:../Library/fat16.c ****  */
 719:../Library/fat16.c **** uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t cou
 720:../Library/fat16.c **** {
 721:../Library/fat16.c ****     #if FAT16_WRITE_SUPPORT
 722:../Library/fat16.c ****         if(!fs)
 723:../Library/fat16.c ****             return 0;
 724:../Library/fat16.c ****     
 725:../Library/fat16.c ****         device_read_t device_read = fs->partition->device_read;
 726:../Library/fat16.c ****         device_write_t device_write = fs->partition->device_write;
 727:../Library/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 728:../Library/fat16.c ****         uint16_t cluster_max = fs->header.fat_size / 2;
 729:../Library/fat16.c ****         uint16_t cluster_next = 0;
 730:../Library/fat16.c ****         uint16_t count_left = count;
 731:../Library/fat16.c ****         uint8_t buffer[2];
 732:../Library/fat16.c ****         uint16_t cluster_new;
 733:../Library/fat16.c ****         for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
 734:../Library/fat16.c ****         {
 735:../Library/fat16.c ****             if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 736:../Library/fat16.c ****                 return 0;
 737:../Library/fat16.c ****     
 738:../Library/fat16.c ****             /* check if this is a free cluster */
 739:../Library/fat16.c ****             if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
 740:../Library/fat16.c ****                 buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
 741:../Library/fat16.c ****             {
 742:../Library/fat16.c ****                 /* allocate cluster */
 743:../Library/fat16.c ****                 if(count_left == count)
 744:../Library/fat16.c ****                 {
 745:../Library/fat16.c ****                     buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 746:../Library/fat16.c ****                     buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 747:../Library/fat16.c ****                 }
 748:../Library/fat16.c ****                 else
 749:../Library/fat16.c ****                 {
 750:../Library/fat16.c ****                     buffer[0] = cluster_next & 0xff;
 751:../Library/fat16.c ****                     buffer[1] = (cluster_next >> 8) & 0xff;
 752:../Library/fat16.c ****                 }
 753:../Library/fat16.c ****     
 754:../Library/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 755:../Library/fat16.c ****                     break;
 756:../Library/fat16.c ****     
 757:../Library/fat16.c ****                 cluster_next = cluster_new;
 758:../Library/fat16.c ****                 if(--count_left == 0)
 759:../Library/fat16.c ****                     break;
 760:../Library/fat16.c ****             }
 761:../Library/fat16.c ****         }
 762:../Library/fat16.c ****     
 763:../Library/fat16.c ****         do
 764:../Library/fat16.c ****         {
 765:../Library/fat16.c ****             if(count_left > 0)
 766:../Library/fat16.c ****                 break;
 767:../Library/fat16.c ****     
 768:../Library/fat16.c ****             /* We allocated a new cluster chain. Now join
 769:../Library/fat16.c ****                                              * it with the existing one.
 770:../Library/fat16.c ****                                              */
 771:../Library/fat16.c ****             if(cluster_num >= 2)
 772:../Library/fat16.c ****             {
 773:../Library/fat16.c ****                 buffer[0] = cluster_next & 0xff;
 774:../Library/fat16.c ****                 buffer[1] = (cluster_next >> 8) & 0xff;
 775:../Library/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
 776:../Library/fat16.c ****                     break;
 777:../Library/fat16.c ****             }
 778:../Library/fat16.c ****     
 779:../Library/fat16.c ****             return cluster_next;
 780:../Library/fat16.c ****     
 781:../Library/fat16.c ****         }
 782:../Library/fat16.c ****         while(0);
 783:../Library/fat16.c ****     
 784:../Library/fat16.c ****         /* No space left on device or writing error.
 785:../Library/fat16.c ****                              * Free up all clusters already allocated.
 786:../Library/fat16.c ****                              */
 787:../Library/fat16.c ****         fat16_free_clusters(fs, cluster_next);
 788:../Library/fat16.c ****     
 789:../Library/fat16.c ****         return 0;
 790:../Library/fat16.c ****     #else
 791:../Library/fat16.c ****         return 0;
 792:../Library/fat16.c ****     #endif
 793:../Library/fat16.c **** }
 794:../Library/fat16.c **** 
 795:../Library/fat16.c **** /**
 796:../Library/fat16.c ****  * \ingroup fat16_fs
 797:../Library/fat16.c ****  * Frees a cluster chain, or a part thereof.
 798:../Library/fat16.c ****  *
 799:../Library/fat16.c ****  * Marks the specified cluster and all clusters which are sequentially
 800:../Library/fat16.c ****  * referenced by it as free. They may then be used again for future
 801:../Library/fat16.c ****  * file allocations.
 802:../Library/fat16.c ****  *
 803:../Library/fat16.c ****  * \note If this function is used for freeing just a part of a cluster
 804:../Library/fat16.c ****  *       chain, the new end of the chain is not correctly terminated
 805:../Library/fat16.c ****  *       within the FAT. Use fat16_terminate_clusters() instead.
 806:../Library/fat16.c ****  *
 807:../Library/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 808:../Library/fat16.c ****  * \param[in] cluster_num The starting cluster of the chain which to free.
 809:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
 810:../Library/fat16.c ****  * \see fat16_terminate_clusters
 811:../Library/fat16.c ****  */
 812:../Library/fat16.c **** uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 813:../Library/fat16.c **** {
 814:../Library/fat16.c ****     #if FAT16_WRITE_SUPPORT
 815:../Library/fat16.c ****         if(!fs || cluster_num < 2)
 816:../Library/fat16.c ****             return 0;
 817:../Library/fat16.c ****     
 818:../Library/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 819:../Library/fat16.c ****         uint8_t buffer[2];
 820:../Library/fat16.c ****         while(cluster_num)
 821:../Library/fat16.c ****         {
 822:../Library/fat16.c ****             if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
 823:../Library/fat16.c ****                 return 0;
 351              		cmp	r0, #0
 352              		cmpne	r3, #1
 353              		.loc 1 823 0
 354              		sub	sp, sp, #4
 355              	.LCFI4:
 356 02c8 F0402DE9 		.loc 1 825 0
 357              		mov	r5, r0
 358 02cc 0118A0E1 		.loc 1 828 0
 359              		ldrhi	r7, [r0, #8]
 360 02d0 2138A0E1 	.LVL34:
 361              		.loc 1 825 0
 824:../Library/fat16.c **** 6_t cluster_num_next = ((uint16_t) buffer[0]) |
 825:../Library/fat16.c ****             ((uint16_t) buffer[1] << 8);
 362              	b	.L46
 363 02d4 000050E3 	.LVL35:
 364 02d8 01005313 	.L49:
 365              	.LBB14:
 366 02dc 04D04DE2 		.loc 1 832 0
 367              		ldr	r3, [r5, #0]
 368              	.LVL36:
 369 02e0 0050A0E1 		ldr	ip, [r3, #0]
 826:../Library/fat16.c ****   
 827:../Library/fat16.c ****             if(cluster_num_next == FAT16_CLUSTER_FREE)
 828:../Library/fat16.c ****                 return 1;
 370              	 pc
 371 02e4 08709085 		bx	ip
 372              		.loc 1 855 0
 373              		mov	lr, #0
 374 02e8 1D00008A 		.loc 1 832 0
 375 02ec 240000EA 		cmp	r0, lr
 376              		.loc 1 857 0
 377              		mov	r1, r6
 378              		mov	r2, #2
 829:../Library/fat16.c ****          if(cluster_num_next == FAT16_CLUSTER_BAD ||
 830:../Library/fat16.c ****                 (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
 831:../Library/fat16.c ****                cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
 832:../Library/fat16.c ****                )
 379              	r4
 380 02f0 003095E5 		.loc 1 832 0
 381              		beq	.L46
 382 02f4 00C093E5 		.loc 1 837 0
 383 02f8 0FE0A0E1 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 384 02fc 1CFF2FE1 		ldrb	ip, [sp, #3]	@ zero_extendqisi2
 833:../Library/fat16.c ****            )
 834:../Library/fat16.c ****             return 0;
 835:../Library/fat16.c **** 			///*
 836:../Library/fat16.c ****             if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
 837:../Library/fat16.c ****                 (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
 838:../Library/fat16.c ****                )
 839:../Library/fat16.c **** 			//*/
 840:../Library/fat16.c ****             cluster_num_next = 0;
 841:../Library/fat16.c ****     
 842:../Library/fat16.c ****             /* free cluster */
 843:../Library/fat16.c ****             buffer[0] = FAT16_CLUSTER_FREE & 0xff;
 844:../Library/fat16.c ****             buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
 845:../Library/fat16.c ****             fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
 846:../Library/fat16.c ****     
 847:../Library/fat16.c ****             /* We continue in any case here, even if freeing the cluster failed.
 848:../Library/fat16.c ****                                              * The cluster is lost, but maybe we can still free up 
 849:../Library/fat16.c ****                                              */
 850:../Library/fat16.c ****     
 851:../Library/fat16.c ****             cluster_num = cluster_num_next;
 852:../Library/fat16.c ****         }
 853:../Library/fat16.c ****     
 854:../Library/fat16.c ****         return 1;
 855:../Library/fat16.c ****     #else
 385              	1 839 0
 386 0300 00E0A0E3 		orrs	r3, r3, ip, asl #8
 387              		.loc 1 837 0
 388 0304 0E0050E1 		mov	r4, r3
 856:../Library/fat16.c **** endif
 857:../Library/fat16.c **** }
 389              	37:
 390 0308 0610A0E1 		.loc 1 841 0
 391 030c 0220A0E3 		add	r3, r3, #16
 392 0310 0400A0E1 		mov	r3, r3, asl #16
 393              		.loc 1 839 0
 394 0314 1A00000A 		beq	.L51
 395              		.loc 1 841 0
 396 0318 0230DDE5 		cmp	r3, #458752
 397 031c 03C0DDE5 		bls	.L46
 398              		.loc 1 848 0
 399 0320 0C3493E1 		ldr	r3, .L58
 400              		.loc 1 856 0
 401 0324 0340A0E1 		strb	lr, [sp, #3]
 402              		.loc 1 855 0
 403              		strb	lr, [sp, #2]
 404 0328 103083E2 		.loc 1 848 0
 405 032c 0338A0E1 		cmp	r4, r3
 406              		movhi	r4, lr
 407 0330 1500000A 		.loc 1 857 0
 408              		ldr	r3, [r5, #0]
 409 0334 070853E3 		ldr	ip, [r3, #8]
 410 0338 1100009A 		mov	lr, pc
 411              		bx	ip
 412 033c 58309FE5 		mov	r3, r4
 413              	.LVL38:
 414 0340 03E0CDE5 	.L48:
 415              		.loc 1 832 0
 416 0344 02E0CDE5 		add	r4, r7, r3, asl #1
 417              	.LVL39:
 418 0348 030054E1 		add	r6, sp, #2
 419 034c 0E40A081 	.LBE14:
 420              		.loc 1 830 0
 421 0350 003095E5 		cmp	r3, #0
 422 0354 08C093E5 	.LBB15:
 423 0358 0FE0A0E1 		.loc 1 832 0
 424 035c 1CFF2FE1 		mov	r1, r6
 425 0360 0430A0E1 		mov	r2, #2
 426              		mov	r0, r4
 427              	.LBE15:
 428              		.loc 1 830 0
 429 0364 834087E0 		bne	.L49
 430              		b	.L51
 431 0368 02608DE2 	.LVL40:
 432              	.L46:
 433              		mov	r0, #0
 434 036c 000053E3 		b	.L56
 435              	.L51:
 436              		mov	r0, #1
 437 0370 0610A0E1 	.L56:
 438 0374 0220A0E3 		.loc 1 870 0
 439 0378 0400A0E1 		add	sp, sp, #4
 440              		ldmfd	sp!, {r4, r5, r6, r7, lr}
 441              		bx	lr
 442 037c DBFFFF1A 	.L59:
 443 0380 010000EA 		.align	2
 444              	.L58:
 445              		.word	65527
 446 0384 0000A0E3 	.LFE13:
 448              		.align	2
 450              	fat16_append_clusters:
 858:../Library/fat16.c **** **
 859:../Library/fat16.c ****  * \ingroup fat16_fs
 860:../Library/fat16.c ****  * Frees a part of a cluster chain and correctly terminates the rest.
 861:../Library/fat16.c ****  *
 862:../Library/fat16.c ****  * Marks the specified cluster as the new end of a cluster chain and
 863:../Library/fat16.c ****  * frees all following clusters.
 864:../Library/fat16.c ****  *
 865:../Library/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 866:../Library/fat16.c ****  * \param[in] cluster_num The new end of the cluster chain.
 867:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
 868:../Library/fat16.c ****  * \see fat16_free_clusters
 869:../Library/fat16.c ****  */
 870:../Library/fat16.c **** uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 451              	gs = 0, pretend = 0, frame = 20
 452 0390 04D08DE2 		@ frame_needed = 0, uses_anonymous_args = 0
 453 0394 F040BDE8 	.LVL41:
 454 0398 1EFF2FE1 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 455              	.LCFI5:
 456              		mov	r1, r1, asl #16
 457              	.LVL42:
 458 039c F7FF0000 		sub	sp, sp, #20
 459              	.LCFI6:
 460              		.loc 1 730 0
 461              		mov	r2, r2, asl #16
 462              	.LVL43:
 463              		mov	r1, r1, lsr #16
 464              		.loc 1 732 0
 465              		subs	r7, r0, #0
 466              		.loc 1 730 0
 467              		str	r1, [sp, #0]
 468              	.LVL44:
 469              		mov	r9, r2, lsr #16
 470 03a0 F04F2DE9 	.LVL45:
 471              		.loc 1 732 0
 472 03a4 0118A0E1 		beq	.L61
 473              	.LVL46:
 474 03a8 14D04DE2 		.loc 1 735 0
 475              		ldr	r2, [r7, #0]
 476              		.loc 1 738 0
 477 03ac 0228A0E1 		ldr	r3, [r7, #12]
 478              		.loc 1 736 0
 479 03b0 2118A0E1 		ldr	r1, [r2, #8]
 480              		.loc 1 738 0
 481 03b4 007050E2 		mov	r3, r3, asl #15
 482              		mov	r4, #0
 483 03b8 00108DE5 	.LVL47:
 484              		.loc 1 735 0
 485 03bc 2298A0E1 		ldr	r2, [r2, #0]
 486              		.loc 1 737 0
 487              		ldr	fp, [r7, #8]
 488 03c0 4E00000A 	.LVL48:
 489              		.loc 1 738 0
 490              		mov	r3, r3, lsr #16
 491 03c4 002097E5 		mov	r5, r9
 492              	.LVL49:
 493 03c8 0C3097E5 		mov	sl, r4
 494              		.loc 1 736 0
 495 03cc 081092E5 		str	r1, [sp, #8]
 496              	.LVL50:
 497 03d0 8337A0E1 		.loc 1 735 0
 498 03d4 0040A0E3 		str	r2, [sp, #4]
 499              	.LVL51:
 500              		.loc 1 738 0
 501 03d8 002092E5 		str	r3, [sp, #12]
 502              	.LVL52:
 503 03dc 08B097E5 		b	.L63
 504              	.LVL53:
 505              	.L64:
 506 03e0 2338A0E1 		.loc 1 745 0
 507 03e4 0950A0E1 		add	r8, fp, r6, asl #1
 508              		mov	r0, r8
 509 03e8 04A0A0E1 		add	r1, sp, #18
 510              		mov	r2, #2
 511 03ec 08108DE5 		ldr	r3, [sp, #4]
 512              		mov	lr, pc
 513              		bx	r3
 514 03f0 04208DE5 		cmp	r0, #0
 515              		beq	.L61
 516              		.loc 1 749 0
 517 03f4 0C308DE5 		ldrb	r3, [sp, #18]	@ zero_extendqisi2
 518              		cmp	r3, #0
 519 03f8 230000EA 		bne	.L66
 520              		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 521              		cmp	r3, #0
 522              		bne	.L66
 523 03fc 86808BE0 		.loc 1 753 0
 524 0400 0800A0E1 		cmp	r5, r9
 525 0404 12108DE2 		.loc 1 755 0
 526 0408 0220A0E3 		mvneq	r3, #0
 527 040c 04309DE5 		.loc 1 761 0
 528 0410 0FE0A0E1 		movne	r3, r4, lsr #8
 529 0414 13FF2FE1 		.loc 1 756 0
 530 0418 000050E3 		streqb	r3, [sp, #19]
 531 041c 3700000A 		.loc 1 755 0
 532              		streqb	r3, [sp, #18]
 533 0420 1230DDE5 		.loc 1 761 0
 534 0424 000053E3 		strneb	r3, [sp, #19]
 535 0428 1600001A 		.loc 1 760 0
 536 042c 1330DDE5 		strneb	r4, [sp, #18]
 537 0430 000053E3 		.loc 1 764 0
 538 0434 1300001A 		mov	r0, r8
 539              		add	r1, sp, #18
 540 0438 090055E1 		mov	r2, #2
 541              		ldr	r3, [sp, #8]
 542 043c 0030E003 		mov	lr, pc
 543              		bx	r3
 544 0440 2434A011 		cmp	r0, #0
 545              		beq	.L72
 546 0444 1330CD05 		.loc 1 768 0
 547              		sub	r3, r5, #1
 548 0448 1230CD05 		mov	r3, r3, asl #16
 549              		movs	r5, r3, lsr #16
 550 044c 1330CD15 		beq	.L82
 551              		mov	r4, r6
 552 0450 1240CD15 	.L66:
 553              		add	sl, sl, #1
 554 0454 0800A0E1 	.LVL54:
 555 0458 12108DE2 	.L63:
 556 045c 0220A0E3 		.loc 1 743 0
 557 0460 08309DE5 		ldr	r1, [sp, #12]
 558 0464 0FE0A0E1 		.loc 1 768 0
 559 0468 13FF2FE1 		mov	r3, sl, asl #16
 560 046c 000050E3 		.loc 1 743 0
 561 0470 0A00000A 		cmp	sl, r1
 562              		.loc 1 768 0
 563 0474 013045E2 		mov	r6, r3, lsr #16
 564 0478 0338A0E1 		.loc 1 743 0
 565 047c 2358B0E1 		bne	.L64
 566 0480 1900000A 	.L72:
 567 0484 0640A0E1 		.loc 1 775 0
 568              		cmp	r5, #0
 569 0488 01A08AE2 		bne	.L77
 570              	.L76:
 571              		.loc 1 781 0
 572              		ldr	r3, [sp, #0]
 573 048c 0C109DE5 		cmp	r3, #1
 574              		bls	.L78
 575 0490 0A38A0E1 		.loc 1 785 0
 576              		ldr	r1, [sp, #0]
 577 0494 01005AE1 		.loc 1 784 0
 578              		mov	r3, r4, lsr #8
 579 0498 2368A0E1 		strb	r3, [sp, #19]
 580              		.loc 1 785 0
 581 049c D6FFFF1A 		add	r0, fp, r1, asl #1
 582              		.loc 1 783 0
 583              		strb	r4, [sp, #18]
 584 04a0 000055E3 		.loc 1 785 0
 585 04a4 1200001A 		add	r1, sp, #18
 586              		mov	r2, #2
 587              		ldr	r3, [sp, #8]
 588 04a8 00309DE5 		mov	lr, pc
 589 04ac 010053E3 		bx	r3
 590 04b0 0B00009A 		cmp	r0, #0
 591              		beq	.L77
 592 04b4 00109DE5 	.LVL55:
 593              	.L78:
 594 04b8 2434A0E1 		.loc 1 789 0
 595 04bc 1330CDE5 		mov	r0, r4
 596              		b	.L80
 597 04c0 81008BE0 	.L82:
 598              		.loc 1 768 0
 599 04c4 1240CDE5 		mov	r4, r6
 600              		b	.L76
 601 04c8 12108DE2 	.LVL56:
 602 04cc 0220A0E3 	.L77:
 603 04d0 08309DE5 		.loc 1 797 0
 604 04d4 0FE0A0E1 		mov	r0, r7
 605 04d8 13FF2FE1 		mov	r1, r4
 606 04dc 000050E3 		bl	fat16_free_clusters
 607 04e0 0300000A 	.LVL57:
 608              	.L61:
 609              		.loc 1 799 0
 610              		mov	r0, #0
 611 04e4 0400A0E1 	.L80:
 612 04e8 050000EA 		.loc 1 803 0
 613              		add	sp, sp, #20
 614              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 615 04ec 0640A0E1 		bx	lr
 616 04f0 ECFFFFEA 	.LFE12:
 618              		.global	__umodsi3
 619              		.align	2
 620 04f4 0700A0E1 		.global	fat16_read_file
 622 04fc 71FFFFEB 	fat16_read_file:
 623              	.LFB17:
 624              		.loc 1 962 0
 625              		@ Function supports interworking.
 626 0500 0000A0E3 		@ args = 0, pretend = 0, frame = 0
 627              		@ frame_needed = 0, uses_anonymous_args = 0
 628              	.LVL58:
 629 0504 14D08DE2 		mov	r2, r2, asl #16
 630 0508 F04FBDE8 	.LVL59:
 631 050c 1EFF2FE1 		.loc 1 964 0
 632              		cmp	r1, #0
 633              		cmpne	r0, #0
 634              		.loc 1 962 0
 635              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 636              	.LCFI7:
 637              		.loc 1 964 0
 638              		mov	r6, r0
 639              		mov	fp, r1
 871:../Library/fat16.c **** 16_WRITE_SUPPORT
 872:../Library/fat16.c ****         if(!fs || cluster_num < 2)
 873:../Library/fat16.c ****             return 0;
 874:../Library/fat16.c ****     
 875:../Library/fat16.c ****         /* fetch next cluster before overwriting the cluster entry */
 876:../Library/fat16.c ****         uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
 877:../Library/fat16.c ****     
 878:../Library/fat16.c ****         /* mark cluster as the last one */
 879:../Library/fat16.c ****         uint8_t buffer[2];
 880:../Library/fat16.c ****         buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 881:../Library/fat16.c ****         buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 882:../Library/fat16.c ****         if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
 883:../Library/fat16.c ****             return 0;
 884:../Library/fat16.c ****     
 885:../Library/fat16.c ****         /* free remaining clusters */
 886:../Library/fat16.c ****         if(cluster_num_next)
 887:../Library/fat16.c ****             return fat16_free_clusters(fs, cluster_num_next);
 888:../Library/fat16.c ****         else
 889:../Library/fat16.c ****             return 1;
 890:../Library/fat16.c ****     #else
 891:../Library/fat16.c ****         return 0;
 892:../Library/fat16.c ****     #endif
 893:../Library/fat16.c **** }
 894:../Library/fat16.c **** 
 895:../Library/fat16.c **** /**
 896:../Library/fat16.c ****  * \ingroup fat16_file
 897:../Library/fat16.c ****  * Opens a file on a FAT16 filesystem.
 898:../Library/fat16.c ****  *
 899:../Library/fat16.c ****  * \param[in] fs The filesystem on which the file to open lies.
 900:../Library/fat16.c ****  * \param[in] dir_entry The directory entry of the file to open.
 901:../Library/fat16.c ****  * \returns The file handle, or 0 on failure.
 902:../Library/fat16.c ****  * \see fat16_close_file
 903:../Library/fat16.c ****  */
 904:../Library/fat16.c **** struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_
 905:../Library/fat16.c **** {
 906:../Library/fat16.c ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
 907:../Library/fat16.c ****         return 0;
 908:../Library/fat16.c **** 
 909:../Library/fat16.c ****     struct fat16_file_struct* fd = malloc(sizeof(*fd));
 910:../Library/fat16.c ****     if(!fd)
 911:../Library/fat16.c ****         return 0;
 912:../Library/fat16.c **** 
 913:../Library/fat16.c ****     memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
 914:../Library/fat16.c ****     fd->fs = fs;
 915:../Library/fat16.c ****     fd->pos = 0;
 916:../Library/fat16.c ****     fd->pos_cluster = dir_entry->cluster;
 917:../Library/fat16.c **** 
 918:../Library/fat16.c ****     return fd;
 919:../Library/fat16.c **** }
 920:../Library/fat16.c **** 
 921:../Library/fat16.c **** /**
 922:../Library/fat16.c ****  * \ingroup fat16_file
 923:../Library/fat16.c ****  * Closes a file.
 924:../Library/fat16.c ****  *
 925:../Library/fat16.c ****  * \param[in] fd The file handle of the file to close.
 926:../Library/fat16.c ****  * \see fat16_open_file
 927:../Library/fat16.c ****  */
 928:../Library/fat16.c **** void fat16_close_file(struct fat16_file_struct* fd)
 929:../Library/fat16.c **** {
 930:../Library/fat16.c ****     if(fd)
 931:../Library/fat16.c ****         free(fd);
 932:../Library/fat16.c **** }
 933:../Library/fat16.c **** 
 934:../Library/fat16.c **** /**
 935:../Library/fat16.c ****  * \ingroup fat16_file
 936:../Library/fat16.c ****  * Reads data from a file.
 937:../Library/fat16.c ****  *
 938:../Library/fat16.c ****  * The data requested is read from the current file location.
 939:../Library/fat16.c ****  *
 940:../Library/fat16.c ****  * \param[in] fd The file handle of the file from which to read.
 941:../Library/fat16.c ****  * \param[out] buffer The buffer into which to write.
 942:../Library/fat16.c ****  * \param[in] buffer_len The amount of data to read.
 943:../Library/fat16.c ****  * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 944:../Library/fat16.c ****  * \see fat16_write_file
 945:../Library/fat16.c ****  */
 946:../Library/fat16.c **** int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
 947:../Library/fat16.c **** {
 948:../Library/fat16.c ****     /* check arguments */
 949:../Library/fat16.c ****     if(!fd || !buffer || buffer_len < 1)
 950:../Library/fat16.c ****         return -1;
 951:../Library/fat16.c **** 
 952:../Library/fat16.c ****     /* determine number of bytes to read */
 953:../Library/fat16.c ****     if(fd->pos + buffer_len > fd->dir_entry.file_size)
 954:../Library/fat16.c ****         buffer_len = fd->dir_entry.file_size - fd->pos;
 955:../Library/fat16.c ****     if(buffer_len == 0)
 956:../Library/fat16.c ****         return 0;
 957:../Library/fat16.c **** 
 958:../Library/fat16.c ****     uint16_t cluster_size = fd->fs->header.cluster_size;
 959:../Library/fat16.c ****     uint16_t cluster_num = fd->pos_cluster;
 960:../Library/fat16.c ****     uint16_t buffer_left = buffer_len;
 961:../Library/fat16.c ****     uint16_t first_cluster_offset = fd->pos % cluster_size;
 962:../Library/fat16.c **** 
 640              		.L87
 641              	.LVL63:
 642              		.loc 1 969 0
 643              		rsb	r3, r7, r2
 644              		mov	r3, r3, asl #16
 645 0510 0228A0E1 		.loc 1 970 0
 646              		movs	r8, r3, lsr #16
 963:../Library/fat16.c **** num = fd->dir_entry.cluster;
 964:../Library/fat16.c **** 
 647              	89
 648 0514 000051E3 	.L87:
 649 0518 00005013 		.loc 1 974 0
 650              		ldrh	r5, [r6, #52]
 651 051c F04F2DE9 	.LVL64:
 652              		.loc 1 973 0
 653              		ldr	r3, [r6, #0]
 654 0520 0060A0E1 		.loc 1 979 0
 655 0524 01B0A0E1 		cmp	r5, #0
 656              		.loc 1 973 0
 657 0528 2288A0E1 		ldrh	r9, [r3, #18]
 658              	.LVL65:
 659              		.loc 1 979 0
 660 052c 5000000A 		bne	.L90
 661              	.LVL66:
 662 0530 000058E3 		.loc 1 981 0
 663 0534 4E00000A 		ldrh	r5, [r6, #38]
 965:../Library/fat16.c ****       if(!cluster_num)
 966:../Library/fat16.c ****         {
 967:../Library/fat16.c ****             if(!fd->pos)
 968:../Library/fat16.c ****                 return 0;
 664              	p	r5, #0
 665 0538 307090E5 		bne	.L92
 666              		.loc 1 985 0
 667 053c 282090E5 		cmp	r7, #0
 668 0540 083087E0 		beq	.L89
 669 0544 020053E1 		b	.L84
 670 0548 0300009A 	.L92:
 671              		.loc 1 991 0
 969:../Library/fat16.c ****         else
 672              	 #0
 673 054c 023067E0 		movne	r4, r7
 674 0550 0338A0E1 	.LVL67:
 970:../Library/fat16.c ****                return -1;
 675              	e	.L95
 676 0554 2388B0E1 		b	.L90
 677 0558 5000000A 	.LVL68:
 678              	.L96:
 971:../Library/fat16.c ****        }
 972:../Library/fat16.c **** 
 973:../Library/fat16.c ****         if(fd->pos)
 974:../Library/fat16.c ****         {
 679              	16:
 680 055c B453D6E1 		.loc 1 997 0
 681              		ldr	r0, [r6, #0]
 682              		bl	fat16_get_next_cluster
 683 0560 003096E5 	.LVL69:
 975:../Library/fat16.c ****         uint32_t pos = fd->pos;
 976:../Library/fat16.c ****             while(pos >= cluster_size)
 977:../Library/fat16.c ****             {
 978:../Library/fat16.c ****                 pos -= cluster_size;
 979:../Library/fat16.c ****                 cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
 684              	 1 998 0
 685 0564 000055E3 		subs	r5, r0, #0
 686              		beq	.L84
 687 0568 B291D3E1 	.LVL70:
 688              	.L95:
 689              		.loc 1 994 0
 690 056c 1100001A 		cmp	r4, r9
 691              		.loc 1 997 0
 980:../Library/fat16.c ****            if(!cluster_num)
 981:../Library/fat16.c ****                     return -1;
 692              	 r5
 693 0570 B652D6E1 		.loc 1 998 0
 982:../Library/fat16.c ****           }
 983:../Library/fat16.c ****         }
 694              	sb	r4, r9, r4
 695 0574 000055E3 		.loc 1 994 0
 696 0578 0200001A 		bcs	.L96
 984:../Library/fat16.c ****   }
 985:../Library/fat16.c **** 
 697              	L71:
 698 057c 000057E3 	.L90:
 699 0580 4600000A 	.LBE16:
 700 0584 3A0000EA 		.loc 1 976 0
 701              		mov	r0, r7
 986:../Library/fat16.c ****   /* read data */
 987:../Library/fat16.c ****     do
 988:../Library/fat16.c ****     {
 989:../Library/fat16.c ****         /* calculate data size to copy from cluster */
 990:../Library/fat16.c ****         uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
 991:../Library/fat16.c ****         (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
 702              	r1, r9
 703 0588 000057E3 		bl	__umodsi3
 704 058c 0740A011 		mov	r0, r0, asl #16
 705              		mov	sl, r0, lsr #16
 706 0590 0400001A 	.LVL72:
 707 0594 070000EA 		mov	r7, r8
 708              	.LVL73:
 709              	.LVL74:
 710              	.L98:
 992:../Library/fat16.c ****   uint16_t copy_length = cluster_size - first_cluster_offset;
 993:../Library/fat16.c ****         if(copy_length > buffer_left)
 994:../Library/fat16.c ****             copy_length = buffer_left;
 995:../Library/fat16.c **** 
 996:../Library/fat16.c ****         /* read data */
 997:../Library/fat16.c ****         if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
 711              	.loc 1 1010 0
 712 0598 000096E5 		rsb	r3, sl, r9
 713 059c 1FFFFFEB 		.loc 1 1009 0
 714              		ldr	ip, [r6, #0]
 998:../Library/fat16.c ****       return buffer_len - buffer_left;
 715              	c 1 1010 0
 716 05a0 005050E2 		mov	r3, r3, asl #16
 717 05a4 3200000A 		mov	r3, r3, lsr #16
 718              	.LVL75:
 719              		cmp	r7, r3
 720              		movcc	r3, r7
 721 05a8 090054E1 	.LVL76:
 722              		.loc 1 1015 0
 723 05ac 0510A0E1 		ldr	r2, [ip, #24]
 724              		.loc 1 1010 0
 725 05b0 044069E0 		mov	r3, r3, asl #16
 726              		mov	r4, r3, lsr #16
 727 05b4 F7FFFF2A 	.LVL77:
 728              		.loc 1 1015 0
 729              		add	r2, sl, r2
 730              		sub	r3, r5, #2
 731              		mla	r0, r9, r3, r2
 732 05b8 0700A0E1 		mov	r1, fp
 733 05bc 0910A0E1 		mov	r2, r4
 734 05c0 FEFFFFEB 		ldr	r3, [ip, #0]
 735 05c4 0008A0E1 		ldr	ip, [r3, #0]
 736 05c8 20A8A0E1 		mov	lr, pc
 737              		bx	ip
 738 05cc 0870A0E1 		.loc 1 1020 0
 739              		rsb	r3, r4, r7
 740              		.loc 1 1015 0
 741              		cmp	r0, #0
 742              		.loc 1 1026 0
 999:../Library/fat16.c ****         /* calculate new file position */
1000:../Library/fat16.c ****         buffer += copy_length;
1001:../Library/fat16.c ****         buffer_left -= copy_length;
1002:../Library/fat16.c ****         fd->pos += copy_length;
1003:../Library/fat16.c **** 
1004:../Library/fat16.c ****         if(first_cluster_offset + copy_length >= cluster_size)
1005:../Library/fat16.c ****         {
1006:../Library/fat16.c ****             /* we are on a cluster boundary, so get the next cluster */
1007:../Library/fat16.c ****             if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
1008:../Library/fat16.c ****             {
1009:../Library/fat16.c ****                 first_cluster_offset = 0;
1010:../Library/fat16.c ****             }
 743              	add	fp, fp, r4
 744 05d0 09306AE0 		.loc 1 1023 0
 745              		add	r2, sl, r4
 746 05d4 00C096E5 		.loc 1 1020 0
 747              		mov	r0, r3, asl #16
 748 05d8 0338A0E1 		.loc 1 1015 0
 749 05dc 2338A0E1 		beq	.L109
 750              		.loc 1 1021 0
 751 05e0 030057E1 		ldr	r3, [r6, #48]
 752 05e4 0730A031 		.loc 1 1023 0
 753              		cmp	r2, r9
1011:../Library/fat16.c **** else
1012:../Library/fat16.c ****             {
1013:../Library/fat16.c ****                 fd->pos_cluster = 0;
1014:../Library/fat16.c ****                 return buffer_len - buffer_left;
1015:../Library/fat16.c ****             }
 754              	1 0
 755 05e8 18209CE5 		add	r3, r3, r4
 756              		str	r3, [r6, #48]
 757 05ec 0338A0E1 		.loc 1 1020 0
 758 05f0 2348A0E1 		mov	r7, r0, lsr #16
 759              		.loc 1 1023 0
 760              		blt	.L102
 761 05f4 02208AE0 		.loc 1 1026 0
 762 05f8 023045E2 		ldr	r0, [r6, #0]
 763 05fc 992320E0 		bl	fat16_get_next_cluster
 764 0600 0B10A0E1 		subs	r5, r0, #0
 765 0604 0420A0E1 		.loc 1 1033 0
 766 0608 00309CE5 		mov	sl, #0
 767 060c 00C093E5 		.loc 1 1026 0
 768 0610 0FE0A0E1 		beq	.L110
 769 0614 1CFF2FE1 	.L102:
1016:../Library/fat16.c ****    }
1017:../Library/fat16.c **** 
1018:../Library/fat16.c ****         fd->pos_cluster = cluster_num;
1019:../Library/fat16.c **** 
1020:../Library/fat16.c ****     }
 770              	1040 0
 771 0618 073064E0 		cmp	r7, #0
 772              	.LBB18:
 773 061c 000050E3 		.loc 1 1037 0
1021:../Library/fat16.c **** hile(buffer_left > 0); /* check if we are done */
1022:../Library/fat16.c **** 
1023:../Library/fat16.c ****     return buffer_len;
1024:../Library/fat16.c **** }
1025:../Library/fat16.c **** 
1026:../Library/fat16.c **** /**
 774              	h	r5, [r6, #52]	@ movhi
 775 0620 0510A0E1 	.LBE18:
 776              		.loc 1 1040 0
 777 0624 04B08BE0 		bne	.L98
 778              		.loc 1 1042 0
 779 0628 04208AE0 		mov	r3, r8, asl #16
 780              		b	.L111
 781 062c 0308A0E1 	.LVL78:
 782              	.L84:
 783 0630 1100000A 		mvn	r0, #0
 784              		b	.L101
 785 0634 303096E5 	.LVL79:
 786              	.L109:
 787 0638 090052E1 	.LBB19:
 788              		.loc 1 1016 0
 789 063c 043083E0 		rsb	r3, r7, r8
 790 0640 303086E5 		mov	r3, r3, asl #16
 791              	.L111:
 792 0644 2078A0E1 		mov	r0, r3, asr #16
 793              		b	.L101
 794 0648 040000BA 	.L110:
 795              		.loc 1 1033 0
 796 064c 000096E5 		rsb	r3, r7, r8
 797 0650 F2FEFFEB 		mov	r3, r3, asl #16
 798 0654 005050E2 		mov	r0, r3, asr #16
1027:../Library/fat16.c **** group fat16_file
1028:../Library/fat16.c ****  * Writes data to a file.
1029:../Library/fat16.c ****  *
1030:../Library/fat16.c ****  * The data is written to the current file location.
1031:../Library/fat16.c ****  *
1032:../Library/fat16.c ****  * \param[in] fd The file handle of the file to which to write.
1033:../Library/fat16.c ****  * \param[in] buffer The buffer from which to read the data to be written.
 799              	[r6, #52]	@ movhi
 800 0658 00A0A0E3 		b	.L101
 801              	.LVL80:
 802 065c 0A00000A 	.L89:
 803              	.LBE19:
 804              		.loc 1 1042 0
1034:../Library/fat16.c **** am[in] buffer_len The amount of data to write.
1035:../Library/fat16.c ****  * \returns The number of bytes written, 0 on disk full, or -1 on failure.
1036:../Library/fat16.c ****  * \see fat16_read_file
1037:../Library/fat16.c ****  */
1038:../Library/fat16.c **** int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
1039:../Library/fat16.c **** {
1040:../Library/fat16.c ****     #if FAT16_WRITE_SUPPORT
 805              	0, #0
 806 0660 000057E3 	.LVL81:
 807              	.L101:
 808              		.loc 1 1043 0
 809 0664 B453C6E1 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 810              		bx	lr
 811              	.LFE17:
1041:../Library/fat16.c ****  /* check arguments */
1042:../Library/fat16.c ****         if(!fd || !buffer || buffer_len < 1)
 813              	2
 814 066c 0838A0E1 		.global	fat16_reset_dir
 816              	fat16_reset_dir:
 817              	.LFB24:
 818 0674 0000E0E3 		.loc 1 1431 0
 819 0678 090000EA 		@ Function supports interworking.
 820              		@ args = 0, pretend = 0, frame = 0
 821              		@ frame_needed = 0, uses_anonymous_args = 0
 822              		@ link register save eliminated.
 823              	.LVL82:
 824 067c 083067E0 		.loc 1 1432 0
 825 0680 0338A0E1 		cmp	r0, #0
 826              		mov	r3, r0
 827 0684 4308A0E1 		.loc 1 1435 0
 828 0688 050000EA 		movne	r3, #0	@ movhi
 829              		strneh	r3, [r0, #48]	@ movhi
 830              		movne	r3, #1
 831 068c 083067E0 		.loc 1 1437 0
 832 0690 0338A0E1 		mov	r0, r3
 833 0694 4308A0E1 	.LVL83:
 834              		.loc 1 1431 0
 835 0698 B453C6E1 		@ lr needed for prologue
 836 069c 000000EA 		.loc 1 1437 0
 837              		bx	lr
 838              	.LFE24:
 840              		.align	2
 841 06a0 0000A0E3 		.global	fat16_set_dir
 843              	fat16_set_dir:
1043:../Library/fat16.c ****           return -1;
 844              	ion supports interworking.
 845 06a4 F04FBDE8 		@ args = 0, pretend = 0, frame = 0
 846 06a8 1EFF2FE1 		@ frame_needed = 0, uses_anonymous_args = 0
 847              		@ link register save eliminated.
 848              	.LVL84:
 849              		.loc 1 1441 0
 850              		cmp	r0, #0
 851              		.loc 1 1440 0
 852              		mov	r1, r1, asl #16
 853              	.LVL85:
1044:../Library/fat16.c ****        if(fd->pos > fd->dir_entry.file_size)
1045:../Library/fat16.c ****             return -1;
1046:../Library/fat16.c ****     
1047:../Library/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1048:../Library/fat16.c ****         uint16_t cluster_num = fd->pos_cluster;
1049:../Library/fat16.c ****         uint16_t buffer_left = buffer_len;
1050:../Library/fat16.c ****         uint16_t first_cluster_offset = fd->pos % cluster_size;
1051:../Library/fat16.c ****     
1052:../Library/fat16.c ****         /* find cluster in which to start writing */
1053:../Library/fat16.c ****         if(!cluster_num)
1054:../Library/fat16.c ****         {
1055:../Library/fat16.c ****             cluster_num = fd->dir_entry.cluster;
1056:../Library/fat16.c ****     
1057:../Library/fat16.c ****             if(!cluster_num)
1058:../Library/fat16.c ****             {
1059:../Library/fat16.c ****                 if(!fd->pos)
1060:../Library/fat16.c ****                 {
1061:../Library/fat16.c ****                     /* empty file */
1062:../Library/fat16.c ****                     fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
1063:../Library/fat16.c ****                     if(!cluster_num)
1064:../Library/fat16.c ****                         return -1;
1065:../Library/fat16.c ****                 }
1066:../Library/fat16.c ****                 else
1067:../Library/fat16.c ****                 {
1068:../Library/fat16.c ****                     return -2;
1069:../Library/fat16.c ****                 }
1070:../Library/fat16.c ****             }
1071:../Library/fat16.c ****     
1072:../Library/fat16.c ****             if(fd->pos)
1073:../Library/fat16.c ****             {
1074:../Library/fat16.c ****                 uint32_t pos = fd->pos;
1075:../Library/fat16.c ****                 uint16_t cluster_num_next;
1076:../Library/fat16.c ****                 while(pos >= cluster_size)
1077:../Library/fat16.c ****                 {
1078:../Library/fat16.c ****                     pos -= cluster_size;
1079:../Library/fat16.c ****                     cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1080:../Library/fat16.c ****                     if(!cluster_num_next && pos == 0)
1081:../Library/fat16.c ****         /* the file exactly ends on a cluster boundary, and we append to it */
1082:../Library/fat16.c ****                         cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1083:../Library/fat16.c ****                     if(!cluster_num_next)
1084:../Library/fat16.c ****                         return -3;
1085:../Library/fat16.c ****     
1086:../Library/fat16.c ****                     cluster_num = cluster_num_next;
1087:../Library/fat16.c ****                 }
1088:../Library/fat16.c ****             }
1089:../Library/fat16.c ****         }
1090:../Library/fat16.c ****     
1091:../Library/fat16.c ****         /* write data */
1092:../Library/fat16.c ****         do
1093:../Library/fat16.c ****         {
1094:../Library/fat16.c ****             /* calculate data size to write to cluster */
1095:../Library/fat16.c ****             uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
1096:../Library/fat16.c ****             (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
1097:../Library/fat16.c ****             uint16_t write_length = cluster_size - first_cluster_offset;
1098:../Library/fat16.c ****             if(write_length > buffer_left)
1099:../Library/fat16.c ****                 write_length = buffer_left;
1100:../Library/fat16.c ****     
1101:../Library/fat16.c ****             /* write data which fits into the current cluster */
1102:../Library/fat16.c ****             if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
1103:../Library/fat16.c ****                 break;
1104:../Library/fat16.c ****     
1105:../Library/fat16.c ****             /* calculate new file position */
1106:../Library/fat16.c ****             buffer += write_length;
1107:../Library/fat16.c ****             buffer_left -= write_length;
1108:../Library/fat16.c ****             fd->pos += write_length;
1109:../Library/fat16.c ****     
1110:../Library/fat16.c ****             if(first_cluster_offset + write_length >= cluster_size)
1111:../Library/fat16.c ****             {
1112:../Library/fat16.c ****                 /* we are on a cluster boundary, so get the next cluster */
1113:../Library/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1114:../Library/fat16.c ****                 if(!cluster_num_next && buffer_left > 0)
1115:../Library/fat16.c ****         /* we reached the last cluster, append a new one */
1116:../Library/fat16.c ****                     cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1117:../Library/fat16.c ****                 if(!cluster_num_next)
1118:../Library/fat16.c ****                 {
1119:../Library/fat16.c ****                     fd->pos_cluster = 0;
1120:../Library/fat16.c ****                     break;
1121:../Library/fat16.c ****                 }
1122:../Library/fat16.c ****     
1123:../Library/fat16.c ****                 cluster_num = cluster_num_next;
1124:../Library/fat16.c ****                 first_cluster_offset = 0;
1125:../Library/fat16.c ****             }
1126:../Library/fat16.c ****     
1127:../Library/fat16.c ****             fd->pos_cluster = cluster_num;
1128:../Library/fat16.c ****     
1129:../Library/fat16.c ****         }
1130:../Library/fat16.c ****         while(buffer_left > 0); /* check if we are done */
1131:../Library/fat16.c ****     
1132:../Library/fat16.c ****         /* update directory entry */
1133:../Library/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1134:../Library/fat16.c ****         {
1135:../Library/fat16.c ****             uint32_t size_old = fd->dir_entry.file_size;
1136:../Library/fat16.c ****     
1137:../Library/fat16.c ****             /* update file size */
1138:../Library/fat16.c ****             fd->dir_entry.file_size = fd->pos;
1139:../Library/fat16.c ****             /* write directory entry */
1140:../Library/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1141:../Library/fat16.c ****             {
1142:../Library/fat16.c ****                 /* We do not return an error here since we actually wrote
1143:../Library/fat16.c ****                                                              * some data to disk. So we calculate t
1144:../Library/fat16.c ****                                                              * we wrote to disk and which lies with
1145:../Library/fat16.c ****                                                              */
1146:../Library/fat16.c ****                 buffer_left = fd->pos - size_old;
1147:../Library/fat16.c ****                 fd->pos = size_old;
1148:../Library/fat16.c ****             }
1149:../Library/fat16.c ****         }
1150:../Library/fat16.c ****     
1151:../Library/fat16.c ****         return buffer_len - buffer_left;
1152:../Library/fat16.c ****     
1153:../Library/fat16.c ****     #else
1154:../Library/fat16.c ****         return -4;
1155:../Library/fat16.c ****     #endif
1156:../Library/fat16.c **** }
1157:../Library/fat16.c **** 
1158:../Library/fat16.c **** /**
1159:../Library/fat16.c ****  * \ingroup fat16_file
1160:../Library/fat16.c ****  * Repositions the read/write file offset.
1161:../Library/fat16.c ****  *
1162:../Library/fat16.c ****  * Changes the file offset where the next call to fat16_read_file()
1163:../Library/fat16.c ****  * or fat16_write_file() starts reading/writing.
1164:../Library/fat16.c ****  *
1165:../Library/fat16.c ****  * If the new offset is beyond the end of the file, fat16_resize_file()
1166:../Library/fat16.c ****  * is implicitly called, i.e. the file is expanded.
1167:../Library/fat16.c ****  *
1168:../Library/fat16.c ****  * The new offset can be given in different ways determined by
1169:../Library/fat16.c ****  * the \c whence parameter:
1170:../Library/fat16.c ****  * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
1171:../Library/fat16.c ****  * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
1172:../Library/fat16.c ****  * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
1173:../Library/fat16.c ****  *
1174:../Library/fat16.c ****  * The resulting absolute offset is written to the location the \c offset
1175:../Library/fat16.c ****  * parameter points to.
1176:../Library/fat16.c ****  *
1177:../Library/fat16.c ****  * \param[in] fd The file decriptor of the file on which to seek.
1178:../Library/fat16.c ****  * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
1179:../Library/fat16.c ****  *                   parameter. The function writes the new absolute offset
1180:../Library/fat16.c ****  *                   to this location before it returns.
1181:../Library/fat16.c ****  * \param[in] whence Affects the way \c offset is interpreted, see above.
1182:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
1183:../Library/fat16.c ****  */
1184:../Library/fat16.c **** uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
1185:../Library/fat16.c **** {
1186:../Library/fat16.c ****     if(!fd || !offset)
1187:../Library/fat16.c ****         return 0;
1188:../Library/fat16.c **** 
1189:../Library/fat16.c ****     uint32_t new_pos = fd->pos;
1190:../Library/fat16.c ****     switch(whence)
1191:../Library/fat16.c ****     {
1192:../Library/fat16.c ****         case FAT16_SEEK_SET:
1193:../Library/fat16.c ****             new_pos = *offset;
1194:../Library/fat16.c ****             break;
1195:../Library/fat16.c ****         case FAT16_SEEK_CUR:
1196:../Library/fat16.c ****             new_pos += *offset;
1197:../Library/fat16.c ****             break;
1198:../Library/fat16.c ****         case FAT16_SEEK_END:
1199:../Library/fat16.c ****             new_pos = fd->dir_entry.file_size + *offset;
1200:../Library/fat16.c ****             break;
1201:../Library/fat16.c ****         default:
1202:../Library/fat16.c ****             return 0;
1203:../Library/fat16.c ****     }
1204:../Library/fat16.c **** 
1205:../Library/fat16.c ****     if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
1206:../Library/fat16.c ****         return 0;
1207:../Library/fat16.c **** 
1208:../Library/fat16.c ****     fd->pos = new_pos;
1209:../Library/fat16.c ****     fd->pos_cluster = 0;
1210:../Library/fat16.c **** 
1211:../Library/fat16.c ****     *offset = new_pos;
1212:../Library/fat16.c ****     return 1;
1213:../Library/fat16.c **** }
1214:../Library/fat16.c **** 
1215:../Library/fat16.c **** /**
1216:../Library/fat16.c ****  * \ingroup fat16_file
1217:../Library/fat16.c ****  * Resizes a file to have a specific size.
1218:../Library/fat16.c ****  *
1219:../Library/fat16.c ****  * Enlarges or shrinks the file pointed to by the file descriptor to have
1220:../Library/fat16.c ****  * exactly the specified size.
1221:../Library/fat16.c ****  *
1222:../Library/fat16.c ****  * If the file is truncated, all bytes having an equal or larger offset
1223:../Library/fat16.c ****  * than the given size are lost. If the file is expanded, the additional
1224:../Library/fat16.c ****  * bytes are allocated.
1225:../Library/fat16.c ****  *
1226:../Library/fat16.c ****  * \note Please be aware that this function just allocates or deallocates disk
1227:../Library/fat16.c ****  * space, it does not explicitely clear it. To avoid data leakage, this
1228:../Library/fat16.c ****  * must be done manually.
1229:../Library/fat16.c ****  *
1230:../Library/fat16.c ****  * \param[in] fd The file decriptor of the file which to resize.
1231:../Library/fat16.c ****  * \param[in] size The new size of the file.
1232:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
1233:../Library/fat16.c ****  */
1234:../Library/fat16.c **** uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
1235:../Library/fat16.c **** {
1236:../Library/fat16.c ****     #if FAT16_WRITE_SUPPORT
1237:../Library/fat16.c ****         if(!fd)
1238:../Library/fat16.c ****             return 0;
1239:../Library/fat16.c ****     
1240:../Library/fat16.c ****         uint16_t cluster_num = fd->dir_entry.cluster;
1241:../Library/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1242:../Library/fat16.c ****         uint32_t size_new = size;
1243:../Library/fat16.c ****     
1244:../Library/fat16.c ****         do
1245:../Library/fat16.c ****         {
1246:../Library/fat16.c ****             if(cluster_num == 0 && size_new == 0)
1247:../Library/fat16.c ****         /* the file stays empty */
1248:../Library/fat16.c ****                 break;
1249:../Library/fat16.c ****     
1250:../Library/fat16.c ****             /* seek to the next cluster as long as we need the space */
1251:../Library/fat16.c ****             while(size_new > cluster_size)
1252:../Library/fat16.c ****             {
1253:../Library/fat16.c ****                 /* get next cluster of file */
1254:../Library/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1255:../Library/fat16.c ****                 if(cluster_num_next)
1256:../Library/fat16.c ****                 {
1257:../Library/fat16.c ****                     cluster_num = cluster_num_next;
1258:../Library/fat16.c ****                     size_new -= cluster_size;
1259:../Library/fat16.c ****                 }
1260:../Library/fat16.c ****                 else
1261:../Library/fat16.c ****                 {
1262:../Library/fat16.c ****                     break;
1263:../Library/fat16.c ****                 }
1264:../Library/fat16.c ****             }
1265:../Library/fat16.c ****     
1266:../Library/fat16.c ****             if(size_new > cluster_size || cluster_num == 0)
1267:../Library/fat16.c ****             {
1268:../Library/fat16.c ****                 /* Allocate new cluster chain and append
1269:../Library/fat16.c ****                                                              * it to the existing one, if available
1270:../Library/fat16.c ****                                                              */
1271:../Library/fat16.c ****                 uint16_t cluster_count = size_new / cluster_size;
1272:../Library/fat16.c ****                 if((uint32_t) cluster_count * cluster_size < size_new)
1273:../Library/fat16.c ****                     ++cluster_count;
1274:../Library/fat16.c ****                 uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_cou
1275:../Library/fat16.c ****                 if(!cluster_new_chain)
1276:../Library/fat16.c ****                     return 0;
1277:../Library/fat16.c ****     
1278:../Library/fat16.c ****                 if(!cluster_num)
1279:../Library/fat16.c ****                 {
1280:../Library/fat16.c ****                     cluster_num = cluster_new_chain;
1281:../Library/fat16.c ****                     fd->dir_entry.cluster = cluster_num;
1282:../Library/fat16.c ****                 }
1283:../Library/fat16.c ****             }
1284:../Library/fat16.c ****     
1285:../Library/fat16.c ****             /* write new directory entry */
1286:../Library/fat16.c ****             fd->dir_entry.file_size = size;
1287:../Library/fat16.c ****             if(size == 0)
1288:../Library/fat16.c ****                 fd->dir_entry.cluster = 0;
1289:../Library/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1290:../Library/fat16.c ****                 return 0;
1291:../Library/fat16.c ****     
1292:../Library/fat16.c ****             if(size == 0)
1293:../Library/fat16.c ****             {
1294:../Library/fat16.c ****                 /* free all clusters of file */
1295:../Library/fat16.c ****                 fat16_free_clusters(fd->fs, cluster_num);
1296:../Library/fat16.c ****             }
1297:../Library/fat16.c ****             else if(size_new <= cluster_size)
1298:../Library/fat16.c ****             {
1299:../Library/fat16.c ****                 /* free all clusters no longer needed */
1300:../Library/fat16.c ****                 fat16_terminate_clusters(fd->fs, cluster_num);
1301:../Library/fat16.c ****             }
1302:../Library/fat16.c ****     
1303:../Library/fat16.c ****         }
1304:../Library/fat16.c ****         while(0);
1305:../Library/fat16.c ****     
1306:../Library/fat16.c ****         /* correct file position */
1307:../Library/fat16.c ****         if(size < fd->pos)
1308:../Library/fat16.c ****         {
1309:../Library/fat16.c ****             fd->pos = size;
1310:../Library/fat16.c ****             fd->pos_cluster = 0;
1311:../Library/fat16.c ****         }
1312:../Library/fat16.c ****     
1313:../Library/fat16.c ****         return 1;
1314:../Library/fat16.c ****     #else
1315:../Library/fat16.c ****         return 0;
1316:../Library/fat16.c ****     #endif
1317:../Library/fat16.c **** }
1318:../Library/fat16.c **** 
1319:../Library/fat16.c **** /**
1320:../Library/fat16.c ****  * \ingroup fat16_dir
1321:../Library/fat16.c ****  * Opens a directory.
1322:../Library/fat16.c ****  *
1323:../Library/fat16.c ****  * \param[in] fs The filesystem on which the directory to open resides.
1324:../Library/fat16.c ****  * \param[in] dir_entry The directory entry which stands for the directory to open.
1325:../Library/fat16.c ****  * \returns An opaque directory descriptor on success, 0 on failure.
1326:../Library/fat16.c ****  * \see fat16_close_dir
1327:../Library/fat16.c ****  */
1328:../Library/fat16.c **** struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_st
1329:../Library/fat16.c **** {
1330:../Library/fat16.c ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
1331:../Library/fat16.c ****         return 0;
1332:../Library/fat16.c **** 
1333:../Library/fat16.c ****     struct fat16_dir_struct* dd = malloc(sizeof(*dd));
1334:../Library/fat16.c ****     if(!dd)
1335:../Library/fat16.c ****         return 0;
1336:../Library/fat16.c **** 
1337:../Library/fat16.c ****     memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
1338:../Library/fat16.c ****     dd->fs = fs;
1339:../Library/fat16.c ****     dd->entry_next = 0;
1340:../Library/fat16.c **** 
1341:../Library/fat16.c ****     return dd;
1342:../Library/fat16.c **** }
1343:../Library/fat16.c **** 
1344:../Library/fat16.c **** /**
1345:../Library/fat16.c ****  * \ingroup fat16_dir
1346:../Library/fat16.c ****  * Closes a directory descriptor.
1347:../Library/fat16.c ****  *
1348:../Library/fat16.c ****  * This function destroys a directory descriptor which was
1349:../Library/fat16.c ****  * previously obtained by calling fat16_open_dir(). When this
1350:../Library/fat16.c ****  * function returns, the given descriptor will be invalid.
1351:../Library/fat16.c ****  *
1352:../Library/fat16.c ****  * \param[in] dd The directory descriptor to close.
1353:../Library/fat16.c ****  * \see fat16_open_dir
1354:../Library/fat16.c ****  */
1355:../Library/fat16.c **** void fat16_close_dir(struct fat16_dir_struct* dd)
1356:../Library/fat16.c **** {
1357:../Library/fat16.c ****     if(dd)
1358:../Library/fat16.c ****         free(dd);
1359:../Library/fat16.c **** }
1360:../Library/fat16.c **** 
1361:../Library/fat16.c **** /**
1362:../Library/fat16.c ****  * \ingroup fat16_dir
1363:../Library/fat16.c ****  * Reads the next directory entry contained within a parent directory.
1364:../Library/fat16.c ****  *
1365:../Library/fat16.c ****  * \param[in] dd The descriptor of the parent directory from which to read the entry.
1366:../Library/fat16.c ****  * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
1367:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
1368:../Library/fat16.c ****  * \see fat16_reset_dir
1369:../Library/fat16.c ****  */
1370:../Library/fat16.c **** uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
1371:../Library/fat16.c **** {
1372:../Library/fat16.c ****     if(!dd || !dir_entry)
1373:../Library/fat16.c ****         return 0;
1374:../Library/fat16.c **** 
1375:../Library/fat16.c ****     if(dd->dir_entry.cluster == 0)
1376:../Library/fat16.c ****     {
1377:../Library/fat16.c ****         /* read entry from root directory */
1378:../Library/fat16.c ****         if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
1379:../Library/fat16.c ****         {
1380:../Library/fat16.c ****             ++dd->entry_next;
1381:../Library/fat16.c ****             return 1;
1382:../Library/fat16.c ****         }
1383:../Library/fat16.c ****     }
1384:../Library/fat16.c ****     else
1385:../Library/fat16.c ****     {
1386:../Library/fat16.c ****         /* read entry from a subdirectory */
1387:../Library/fat16.c ****         if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
1388:../Library/fat16.c ****         {
1389:../Library/fat16.c ****             ++dd->entry_next;
1390:../Library/fat16.c ****             return 1;
1391:../Library/fat16.c ****         }
1392:../Library/fat16.c ****     }
1393:../Library/fat16.c **** 
1394:../Library/fat16.c ****     /* restart reading */
1395:../Library/fat16.c ****     dd->entry_next = 0;
1396:../Library/fat16.c **** 
1397:../Library/fat16.c ****     return 0;
1398:../Library/fat16.c **** }
1399:../Library/fat16.c **** 
1400:../Library/fat16.c **** /**
1401:../Library/fat16.c ****  * \ingroup fat16_dir
1402:../Library/fat16.c ****  * Resets a directory handle.
1403:../Library/fat16.c ****  *
1404:../Library/fat16.c ****  * Resets the directory handle such that reading restarts
1405:../Library/fat16.c ****  * with the first directory entry.
1406:../Library/fat16.c ****  *
1407:../Library/fat16.c ****  * \param[in] dd The directory handle to reset.
1408:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
1409:../Library/fat16.c ****  * \see fat16_read_dir
1410:../Library/fat16.c ****  */
1411:../Library/fat16.c **** uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
1412:../Library/fat16.c **** {
1413:../Library/fat16.c ****     if(!dd)
1414:../Library/fat16.c ****         return 0;
1415:../Library/fat16.c **** 
1416:../Library/fat16.c ****     dd->entry_next = 0;
1417:../Library/fat16.c ****     return 1;
1418:../Library/fat16.c **** }
1419:../Library/fat16.c **** 
1420:../Library/fat16.c **** uint8_t fat16_set_dir(struct fat16_dir_struct* dd, uint16_t offset)
1421:../Library/fat16.c **** {
1422:../Library/fat16.c ****     if(!dd)
1423:../Library/fat16.c ****         return 0;
1424:../Library/fat16.c **** 
1425:../Library/fat16.c ****     dd->entry_next = offset;
1426:../Library/fat16.c ****     return 1;
1427:../Library/fat16.c **** }
1428:../Library/fat16.c **** 
1429:../Library/fat16.c **** /**
1430:../Library/fat16.c ****  * \ingroup fat16_fs
1431:../Library/fat16.c ****  * Writes a directory entry to disk.
 854              	41 0
 855              		mov	r3, r0
 856              		.loc 1 1440 0
 857              		mov	r1, r1, lsr #16
 858              	.LVL86:
 859              		.loc 1 1444 0
1432:../Library/fat16.c **** haracters are used for the filename.
 860              		r3, #1
 861 06ac 000050E3 		strneh	r1, [r0, #48]	@ movhi
 862 06b0 0030A0E1 		.loc 1 1446 0
1433:../Library/fat16.c **** * The extension, if any, is made up of the first three characters
1434:../Library/fat16.c ****  * following the last dot within the long filename. If the
1435:../Library/fat16.c ****  * filename (without the extension) is longer than eight characters,
 863              	v	r0, r3
 864 06b4 0030A013 	.LVL87:
 865 06b8 B033C011 		.loc 1 1440 0
 866 06bc 0130A013 		@ lr needed for prologue
1436:../Library/fat16.c **** the lower byte of the cluster number replaces the last two
1437:../Library/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
 867              	c 1 1446 0
 868 06c0 0300A0E1 		bx	lr
 869              	.LFE25:
 871              		.align	2
 872              		.global	fat16_delete_file
 874              	fat16_delete_file:
 875              	.LFB28:
 876              		.loc 1 1801 0
 877              		@ Function supports interworking.
 878              		@ args = 0, pretend = 0, frame = 12
 879              		@ frame_needed = 0, uses_anonymous_args = 0
 880              	.LVL88:
1438:../Library/fat16.c ****  responsibility to avoid name clashes.
1439:../Library/fat16.c ****  *
1440:../Library/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 881              	4, r5, r6, r7, lr}
 882              	.LCFI8:
 883              		.loc 1 1803 0
 884              		cmp	r1, #0
 885              		cmpne	r0, #0
 886              		.loc 1 1801 0
1441:../Library/fat16.c **** \param[in] dir_entry The directory entry to write.
 887              	p, sp, #12
 888 06c8 000050E3 	.LCFI9:
 889              		.loc 1 1803 0
 890 06cc 0118A0E1 		mov	r6, r0
 891              		mov	r7, r1
 892              		beq	.L123
 893 06d0 0030A0E1 	.LVL89:
 894              		.loc 1 1807 0
 895 06d4 2118A0E1 		ldr	r5, [r1, #40]
 896              	.LVL90:
1442:../Library/fat16.c **** * \returns 0 on failure, 1 on success.
1443:../Library/fat16.c ****  */
1444:../Library/fat16.c **** uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct
 897              	08 0
 898 06d8 0130A013 		cmp	r5, #0
 899 06dc B013C011 		beq	.L123
1445:../Library/fat16.c ****    #if FAT16_WRITE_SUPPORT
1446:../Library/fat16.c ****         if(!fs || !dir_entry)
 900              	32:
 901 06e0 0300A0E1 		.loc 1 1815 0
 902              		mov	r1, sp
 903              		mov	r0, r5
 904              		mov	r2, #12
 905              		ldr	r3, [r6, #0]
 906 06e4 1EFF2FE1 		ldr	ip, [r3, #0]
 907              		mov	lr, pc
 908              		bx	ip
 909              		cmp	r0, #0
 910              		mov	r4, sp
 911              		.loc 1 1822 0
 912              		mov	r0, r5
 913              		mov	r1, sp
1447:../Library/fat16.c ****           return 0;
1448:../Library/fat16.c ****     
1449:../Library/fat16.c ****         device_write_t device_write = fs->partition->device_write;
1450:../Library/fat16.c ****         uint32_t offset = dir_entry->entry_offset;
1451:../Library/fat16.c ****         uint8_t name_len = strlen(dir_entry->long_name);
1452:../Library/fat16.c ****         uint8_t lfn_entry_count = (name_len + 12) / 13;
1453:../Library/fat16.c ****         uint8_t buffer[32];
1454:../Library/fat16.c ****     
1455:../Library/fat16.c ****         /* write 8.3 entry */
1456:../Library/fat16.c ****     
1457:../Library/fat16.c ****         /* generate 8.3 file name */
1458:../Library/fat16.c ****         memset(&buffer[0], ' ', 11);
1459:../Library/fat16.c ****         char* name_ext = strrchr(dir_entry->long_name, '.');
1460:../Library/fat16.c ****         if(name_ext)
1461:../Library/fat16.c ****         {
1462:../Library/fat16.c ****             ++name_ext;
1463:../Library/fat16.c ****     
1464:../Library/fat16.c ****             uint8_t name_ext_len = strlen(name_ext);
1465:../Library/fat16.c ****             name_len -= name_ext_len + 1;
1466:../Library/fat16.c ****     
1467:../Library/fat16.c ****             if(name_ext_len > 3)
1468:../Library/fat16.c ****                 name_ext_len = 3;
1469:../Library/fat16.c ****     
1470:../Library/fat16.c ****             memcpy(&buffer[8], name_ext, name_ext_len);
1471:../Library/fat16.c ****         }
1472:../Library/fat16.c ****     
1473:../Library/fat16.c ****         if(name_len <= 8)
1474:../Library/fat16.c ****         {
1475:../Library/fat16.c ****             memcpy(buffer, dir_entry->long_name, name_len);
1476:../Library/fat16.c ****         }
1477:../Library/fat16.c ****         else
1478:../Library/fat16.c ****         {
1479:../Library/fat16.c ****             memcpy(buffer, dir_entry->long_name, 8);
1480:../Library/fat16.c ****     
1481:../Library/fat16.c ****             /* Minimize 8.3 name clashes by appending
1482:../Library/fat16.c ****                                              * the lower byte of the cluster number.
1483:../Library/fat16.c ****                                              */
1484:../Library/fat16.c ****             uint8_t num = dir_entry->cluster & 0xff;
1485:../Library/fat16.c ****     
1486:../Library/fat16.c ****             buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
1487:../Library/fat16.c ****             num &= 0x0f;
1488:../Library/fat16.c ****             buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
1489:../Library/fat16.c ****         }
1490:../Library/fat16.c ****     
1491:../Library/fat16.c ****         /* fill directory entry buffer */
1492:../Library/fat16.c ****         memset(&buffer[11], 0, sizeof(buffer) - 11);
1493:../Library/fat16.c ****         buffer[0x0b] = dir_entry->attributes;
1494:../Library/fat16.c **** 
1495:../Library/fat16.c ****         //Not used in bootloader
1496:../Library/fat16.c **** 		#ifdef MAIN_FIRMWARE
1497:../Library/fat16.c **** 			//Added modified date/time 12-26-07
1498:../Library/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1499:../Library/fat16.c **** 			char * current_time;
1500:../Library/fat16.c **** /*			current_time = GPS_get_time();
1501:../Library/fat16.c **** 			char * current_date;
1502:../Library/fat16.c **** 			current_date = GPS_get_date();
1503:../Library/fat16.c **** 			
1504:../Library/fat16.c **** 			uint16_t modified_time, modified_date;
1505:../Library/fat16.c **** 			uint8_t c_hour, c_minute, c_second;
1506:../Library/fat16.c **** 			uint8_t c_year, c_month, c_day;
1507:../Library/fat16.c **** 			
1508:../Library/fat16.c **** 			c_hour = (current_time[0] - '0') * 10;
1509:../Library/fat16.c **** 			c_hour += (current_time[1] - '0');
1510:../Library/fat16.c **** 			c_minute = (current_time[3] - '0') * 10;
1511:../Library/fat16.c **** 			c_minute += (current_time[4] - '0');
1512:../Library/fat16.c **** 			c_second = (current_time[6] - '0') * 10;
1513:../Library/fat16.c **** 			c_second += (current_time[7] - '0');
1514:../Library/fat16.c **** 			
1515:../Library/fat16.c **** 			c_day = (current_date[0] - '0') * 10;
1516:../Library/fat16.c **** 			c_day += (current_date[1] - '0');
1517:../Library/fat16.c **** 			c_month = (current_date[3] - '0') * 10;
1518:../Library/fat16.c **** 			c_month += (current_date[4] - '0');
1519:../Library/fat16.c **** 			c_year = (current_date[6] - '0') * 10;
1520:../Library/fat16.c **** 			c_year += (current_date[7] - '0');
1521:../Library/fat16.c **** 			
1522:../Library/fat16.c **** 			//Correct for 1980 = 0, 2000 = 20, year code
1523:../Library/fat16.c **** 			c_year += 20;
1524:../Library/fat16.c **** 			
1525:../Library/fat16.c **** 			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
1526:../Library/fat16.c **** 			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);
1527:../Library/fat16.c **** 
1528:../Library/fat16.c **** 			//Do a little error correction
1529:../Library/fat16.c **** 			if (c_year < 26) //26 = 2006
1530:../Library/fat16.c **** 			{
1531:../Library/fat16.c **** 				modified_time = 0;
1532:../Library/fat16.c **** 				modified_date = 0;
1533:../Library/fat16.c **** 			}
1534:../Library/fat16.c **** 
1535:../Library/fat16.c **** 			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
1536:../Library/fat16.c **** 			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
1537:../Library/fat16.c **** 			//rprintf("mod_time=%x\n", modified_time);
1538:../Library/fat16.c **** 			//rprintf("mod_date=%x\n", modified_date);
1539:../Library/fat16.c **** 			
1540:../Library/fat16.c **** 			buffer[0x16] = (modified_time >> 0) & 0xFF;
1541:../Library/fat16.c **** 			buffer[0x17] = (modified_time >> 8) & 0xFF;
1542:../Library/fat16.c **** 			buffer[0x18] = (modified_date >> 0) & 0xFF;
1543:../Library/fat16.c **** 			buffer[0x19] = (modified_date >> 8) & 0xFF;
1544:../Library/fat16.c **** 			*/
1545:../Library/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1546:../Library/fat16.c **** 		#endif
1547:../Library/fat16.c **** 
1548:../Library/fat16.c ****         buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
1549:../Library/fat16.c ****         buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
1550:../Library/fat16.c ****         buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
1551:../Library/fat16.c ****         buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
1552:../Library/fat16.c ****         buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
1553:../Library/fat16.c ****         buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
1554:../Library/fat16.c ****     
1555:../Library/fat16.c ****         /* write to disk */
1556:../Library/fat16.c ****         if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
1557:../Library/fat16.c ****             return 0;
1558:../Library/fat16.c ****     
1559:../Library/fat16.c ****         /* calculate checksum of 8.3 name */
1560:../Library/fat16.c ****         uint8_t checksum = buffer[0];
1561:../Library/fat16.c ****         uint8_t i;
1562:../Library/fat16.c ****         for(i = 1; i < 11; ++i)
1563:../Library/fat16.c ****             checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
1564:../Library/fat16.c ****     
1565:../Library/fat16.c ****         /* write lfn entries */
1566:../Library/fat16.c ****         uint8_t lfn_entry;
1567:../Library/fat16.c ****         for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
1568:../Library/fat16.c ****         {
1569:../Library/fat16.c ****             memset(buffer, 0, sizeof(buffer));
1570:../Library/fat16.c ****             memset(&buffer[0x01], 0xff, 10);
1571:../Library/fat16.c ****             memset(&buffer[0x0e], 0xff, 12);
1572:../Library/fat16.c ****             memset(&buffer[0x1c], 0xff, 4);
1573:../Library/fat16.c ****     
1574:../Library/fat16.c ****             buffer[0x00] = lfn_entry;
1575:../Library/fat16.c ****             if(lfn_entry == lfn_entry_count)
1576:../Library/fat16.c ****                 buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
1577:../Library/fat16.c ****     
1578:../Library/fat16.c ****             /* set file name */
1579:../Library/fat16.c ****             const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
1580:../Library/fat16.c ****             i = 1;
1581:../Library/fat16.c ****             while(i < 0x1f)
1582:../Library/fat16.c ****             {
1583:../Library/fat16.c ****                 buffer[i++] = *long_name_curr;
1584:../Library/fat16.c ****                 buffer[i++] = 0;
1585:../Library/fat16.c ****     
1586:../Library/fat16.c ****                 switch(i)
1587:../Library/fat16.c ****                 {
1588:../Library/fat16.c ****                     case 0x0b:
1589:../Library/fat16.c ****                         i = 0x0e;
1590:../Library/fat16.c ****                         break;
1591:../Library/fat16.c ****                     case 0x1a:
1592:../Library/fat16.c ****                         i = 0x1c;
1593:../Library/fat16.c ****                         break;
1594:../Library/fat16.c ****                 }
1595:../Library/fat16.c ****     
1596:../Library/fat16.c ****                 if(!*long_name_curr++)
1597:../Library/fat16.c ****                     break;
1598:../Library/fat16.c ****             }
1599:../Library/fat16.c ****     
1600:../Library/fat16.c ****             /* mark as lfn entry */
1601:../Library/fat16.c ****             buffer[0x0b] = 0x0f;
1602:../Library/fat16.c ****     
1603:../Library/fat16.c ****             /* set checksum */
1604:../Library/fat16.c ****             buffer[0x0d] = checksum;
1605:../Library/fat16.c ****     
1606:../Library/fat16.c ****             /* write entry */
1607:../Library/fat16.c ****             device_write(offset, buffer, sizeof(buffer));
1608:../Library/fat16.c ****     
1609:../Library/fat16.c ****             offset += sizeof(buffer);
1610:../Library/fat16.c ****         }
1611:../Library/fat16.c ****     
1612:../Library/fat16.c ****         return 1;
1613:../Library/fat16.c ****     
1614:../Library/fat16.c ****     #else
1615:../Library/fat16.c ****         return 0;
1616:../Library/fat16.c ****     #endif
1617:../Library/fat16.c **** }
1618:../Library/fat16.c **** 
1619:../Library/fat16.c **** /**
1620:../Library/fat16.c ****  * \ingroup fat16_file
1621:../Library/fat16.c ****  * Creates a file.
1622:../Library/fat16.c ****  *
1623:../Library/fat16.c ****  * Creates a file and obtains the directory entry of the
1624:../Library/fat16.c ****  * new file. If the file to create already exists, the
1625:../Library/fat16.c ****  * directory entry of the existing file will be returned
1626:../Library/fat16.c ****  * within the dir_entry parameter.
1627:../Library/fat16.c ****  *
1628:../Library/fat16.c ****  * \note The file name is not checked for invalid characters.
1629:../Library/fat16.c ****  *
1630:../Library/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1631:../Library/fat16.c ****  * simple. The first eight characters are used for the filename.
1632:../Library/fat16.c ****  * The extension, if any, is made up of the first three characters
1633:../Library/fat16.c ****  * following the last dot within the long filename. If the
1634:../Library/fat16.c ****  * filename (without the extension) is longer than eight characters,
1635:../Library/fat16.c ****  * the lower byte of the cluster number replaces the last two
1636:../Library/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1637:../Library/fat16.c ****  * responsibility to avoid name clashes.
1638:../Library/fat16.c ****  *
1639:../Library/fat16.c ****  * \param[in] parent The handle of the directory in which to create the file.
1640:../Library/fat16.c ****  * \param[in] file The name of the file to create.
1641:../Library/fat16.c ****  * \param[out] dir_entry The directory entry to fill for the new file.
1642:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
1643:../Library/fat16.c ****  * \see fat16_delete_file
1644:../Library/fat16.c ****  */
1645:../Library/fat16.c **** uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry
1646:../Library/fat16.c **** {
1647:../Library/fat16.c ****     #if FAT16_WRITE_SUPPORT
1648:../Library/fat16.c ****         if(!parent || !file || !file[0])
1649:../Library/fat16.c ****             return 0;
1650:../Library/fat16.c ****     
1651:../Library/fat16.c ****         /* check if the file already exists */
1652:../Library/fat16.c ****         while(1)
1653:../Library/fat16.c ****         {
1654:../Library/fat16.c ****             if(!fat16_read_dir(parent, dir_entry))
1655:../Library/fat16.c ****                 break;
1656:../Library/fat16.c ****     
1657:../Library/fat16.c ****             if(strcmp(file, dir_entry->long_name) == 0)
1658:../Library/fat16.c ****             {
1659:../Library/fat16.c ****                 fat16_reset_dir(parent);
1660:../Library/fat16.c ****                 return 1;
1661:../Library/fat16.c ****             }
1662:../Library/fat16.c ****         }
1663:../Library/fat16.c ****     
1664:../Library/fat16.c ****         memset(dir_entry, 0, sizeof(*dir_entry));
1665:../Library/fat16.c ****         strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
1666:../Library/fat16.c ****     
1667:../Library/fat16.c ****         /* search for a place where to write the directory entry to disk */
1668:../Library/fat16.c ****         uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
1669:../Library/fat16.c ****         uint8_t free_dir_entries_found = 0;
1670:../Library/fat16.c ****         struct fat16_fs_struct* fs = parent->fs;
1671:../Library/fat16.c ****         uint16_t cluster_num = parent->dir_entry.cluster;
1672:../Library/fat16.c ****         uint32_t dir_entry_offset = 0;
1673:../Library/fat16.c ****         uint32_t offset = 0;
1674:../Library/fat16.c ****         uint32_t offset_to = 0;
1675:../Library/fat16.c ****     
1676:../Library/fat16.c ****         if(cluster_num == 0)
1677:../Library/fat16.c ****         {
1678:../Library/fat16.c ****             /* we read/write from the root directory entry */
1679:../Library/fat16.c ****             offset = fs->header.root_dir_offset;
1680:../Library/fat16.c ****             offset_to = fs->header.cluster_zero_offset;
1681:../Library/fat16.c ****             dir_entry_offset = offset;
1682:../Library/fat16.c ****         }
1683:../Library/fat16.c ****     
1684:../Library/fat16.c ****         while(1)
1685:../Library/fat16.c ****         {
1686:../Library/fat16.c ****             if(offset == offset_to)
1687:../Library/fat16.c ****             {
1688:../Library/fat16.c ****                 if(cluster_num == 0)
1689:../Library/fat16.c **** 				/* We iterated through the whole root directory entry
1690:../Library/fat16.c ****                 * and could not find enough space for the directory entry.
1691:../Library/fat16.c ****                 */
1692:../Library/fat16.c ****                 return 0;
1693:../Library/fat16.c ****     
1694:../Library/fat16.c ****                 if(offset)
1695:../Library/fat16.c ****                 {
1696:../Library/fat16.c ****                     /* We reached a cluster boundary and have to
1697:../Library/fat16.c ****                     * switch to the next cluster.
1698:../Library/fat16.c ****                     */
1699:../Library/fat16.c ****     
1700:../Library/fat16.c ****                     uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
1701:../Library/fat16.c ****                     if(!cluster_next)
1702:../Library/fat16.c ****                     {
1703:../Library/fat16.c ****                         cluster_next = fat16_append_clusters(fs, cluster_num, 1);
1704:../Library/fat16.c ****                         if(!cluster_next)
1705:../Library/fat16.c ****                             return 0;
1706:../Library/fat16.c ****     
1707:../Library/fat16.c ****                         /* we appended a new cluster and know it is free */
1708:../Library/fat16.c ****                         dir_entry_offset = fs->header.cluster_zero_offset +
1709:../Library/fat16.c ****                         (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
1710:../Library/fat16.c ****     
1711:../Library/fat16.c ****                         /* TODO: This cluster has to be zeroed in an efficient way, or at least
1712:../Library/fat16.c ****                         *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
1713:../Library/fat16.c ****                         */
1714:../Library/fat16.c ****                         break;
1715:../Library/fat16.c ****                     }
1716:../Library/fat16.c ****                     cluster_num = cluster_next;
1717:../Library/fat16.c ****                 }
1718:../Library/fat16.c ****     
1719:../Library/fat16.c ****                 offset = fs->header.cluster_zero_offset +
1720:../Library/fat16.c ****                 (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
1721:../Library/fat16.c ****                 offset_to = offset + fs->header.cluster_size;
1722:../Library/fat16.c ****                 dir_entry_offset = offset;
1723:../Library/fat16.c ****                 free_dir_entries_found = 0;
1724:../Library/fat16.c ****             }
1725:../Library/fat16.c ****     
1726:../Library/fat16.c ****             /* read next lfn or 8.3 entry */
1727:../Library/fat16.c ****             uint8_t first_char;
1728:../Library/fat16.c ****             if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
1729:../Library/fat16.c ****                 return 0;
1730:../Library/fat16.c ****     
1731:../Library/fat16.c ****             /* check if we found a free directory entry */
1732:../Library/fat16.c ****             if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
1733:../Library/fat16.c ****             {
1734:../Library/fat16.c ****                 /* check if we have the needed number of available entries */
1735:../Library/fat16.c ****                 ++free_dir_entries_found;
1736:../Library/fat16.c ****                 if(free_dir_entries_found >= free_dir_entries_needed)
1737:../Library/fat16.c ****                     break;
1738:../Library/fat16.c ****     
1739:../Library/fat16.c ****                 offset += 32;
1740:../Library/fat16.c ****             }
1741:../Library/fat16.c ****             else
1742:../Library/fat16.c ****             {
1743:../Library/fat16.c ****                 offset += 32;
1744:../Library/fat16.c ****                 dir_entry_offset = offset;
1745:../Library/fat16.c ****                 free_dir_entries_found = 0;
1746:../Library/fat16.c ****             }
1747:../Library/fat16.c ****         }
1748:../Library/fat16.c **** 
1749:../Library/fat16.c ****         /* write directory entry to disk */
1750:../Library/fat16.c ****         dir_entry->entry_offset = dir_entry_offset;
1751:../Library/fat16.c ****         if(!fat16_write_dir_entry(fs, dir_entry))
1752:../Library/fat16.c ****             return 0;
1753:../Library/fat16.c ****     
1754:../Library/fat16.c ****         return 1;
1755:../Library/fat16.c ****     
1756:../Library/fat16.c ****     #else
1757:../Library/fat16.c ****         return 0;
1758:../Library/fat16.c ****     #endif
1759:../Library/fat16.c **** }
1760:../Library/fat16.c **** 
1761:../Library/fat16.c **** /**
1762:../Library/fat16.c ****  * \ingroup fat16_file
1763:../Library/fat16.c ****  * Deletes a file or directory.
1764:../Library/fat16.c ****  *
1765:../Library/fat16.c ****  * It is not checked if the file to delete is a directory.
1766:../Library/fat16.c ****  * If a directory is deleted without first deleting its
1767:../Library/fat16.c ****  * subdirectories and files, disk space occupied by these
1768:../Library/fat16.c ****  * files will get wasted as there is no chance to release
1769:../Library/fat16.c ****  * it and mark it as free.
1770:../Library/fat16.c ****  *
1771:../Library/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1772:../Library/fat16.c ****  * \param[in] dir_entry The directory entry of the file to delete.
1773:../Library/fat16.c ****  * \returns 0 on failure, 1 on success.
1774:../Library/fat16.c ****  * \see fat16_create_file
1775:../Library/fat16.c ****  */
1776:../Library/fat16.c **** uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
1777:../Library/fat16.c **** {
1778:../Library/fat16.c ****     #if FAT16_WRITE_SUPPORT
1779:../Library/fat16.c ****         if(!fs || !dir_entry)
1780:../Library/fat16.c ****             return 0;
1781:../Library/fat16.c ****     
1782:../Library/fat16.c ****         /* get offset of the file's directory entry */
1783:../Library/fat16.c ****         uint32_t dir_entry_offset = dir_entry->entry_offset;
1784:../Library/fat16.c ****         if(!dir_entry_offset)
1785:../Library/fat16.c ****             return 0;
1786:../Library/fat16.c ****     
1787:../Library/fat16.c ****         uint8_t buffer[12];
1788:../Library/fat16.c ****         while(1)
1789:../Library/fat16.c ****         {
1790:../Library/fat16.c ****             /* read directory entry */
1791:../Library/fat16.c ****             if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
1792:../Library/fat16.c ****                 return 0;
1793:../Library/fat16.c ****     
1794:../Library/fat16.c ****             /* mark the directory entry as deleted */
1795:../Library/fat16.c ****             buffer[0] = FAT16_DIRENTRY_DELETED;
1796:../Library/fat16.c ****     
1797:../Library/fat16.c ****             /* write back entry */
1798:../Library/fat16.c ****             if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
1799:../Library/fat16.c ****                 return 0;
1800:../Library/fat16.c ****     
1801:../Library/fat16.c ****             /* check if we deleted the whole entry */
 914              	.loc 1 1829 0
 915              		add	r5, r5, #32
 916              		.loc 1 1815 0
 917              		beq	.L123
 918              		.loc 1 1819 0
 919 06e8 F0402DE9 		mvn	r3, #26
 920              		strb	r3, [sp, #0]
1802:../Library/fat16.c ****  }
1803:../Library/fat16.c ****     
 921              	 1822 0
 922 06ec 000051E3 		ldr	r3, [r6, #0]
 923 06f0 00005013 		ldr	ip, [r3, #8]
 924              		mov	lr, pc
 925 06f4 0CD04DE2 		bx	ip
 926              		cmp	r0, #0
 927              		beq	.L123
 928 06f8 0060A0E1 		.loc 1 1826 0
 929 06fc 0170A0E1 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 930 0700 1F00000A 		cmp	r3, #15
 931              		beq	.L132
1804:../Library/fat16.c **** /
1805:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1806:../Library/fat16.c ****                 break;
1807:../Library/fat16.c ****     
 932              	5 0
 933 0704 285091E5 		mov	r0, r6
 934              		ldrh	r1, [r7, #34]
1808:../Library/fat16.c ****  
 935              		fat16_free_clusters
 936 0708 000055E3 		b	.L130
 937 070c 1C00000A 	.LVL91:
 938              	.L123:
1809:../Library/fat16.c **** y */
1810:../Library/fat16.c ****             if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
1811:../Library/fat16.c ****                 return 0;
1812:../Library/fat16.c ****     
1813:../Library/fat16.c ****             /* check if we deleted the whole entry */
1814:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1815:../Library/fat16.c ****                 break;
 939              		r0, #0
 940 0710 0D10A0E1 	.L130:
 941 0714 0500A0E1 		.loc 1 1839 0
 942 0718 0C20A0E3 		add	sp, sp, #12
 943 071c 003096E5 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 944 0720 00C093E5 		bx	lr
 945 0724 0FE0A0E1 	.LFE28:
 947 072c 000050E3 		.align	2
 948 0730 0D40A0E1 		.global	fat16_get_fs_size
1816:../Library/fat16.c **** 0;
1817:../Library/fat16.c ****     
1818:../Library/fat16.c ****             /* check if we deleted the whole entry */
1819:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1820:../Library/fat16.c ****                 break;
1821:../Library/fat16.c ****     
1822:../Library/fat16.c ****             dir_entry_offset += 32;
 949              	16_get_fs_size, %function
 950 0734 0500A0E1 	fat16_get_fs_size:
 951 0738 0D10A0E1 	.LFB29:
 952 073c 0C20A0E3 		.loc 1 1849 0
1823:../Library/fat16.c **** the whole entry */
1824:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1825:../Library/fat16.c ****                 break;
1826:../Library/fat16.c ****     
1827:../Library/fat16.c ****             dir_entry_offset += 32;
1828:../Library/fat16.c ****         }
1829:../Library/fat16.c ****     
 953              	unction supports interworking.
 954 0740 205085E2 		@ args = 0, pretend = 0, frame = 0
 955              		@ frame_needed = 0, uses_anonymous_args = 0
 956 0744 0E00000A 		@ link register save eliminated.
 957              	.LVL92:
 958 0748 1A30E0E3 		.loc 1 1850 0
 959 074c 0030CDE5 		cmp	r0, #0
 960              		.loc 1 1853 0
 961 0750 003096E5 		ldrne	r3, [r0, #12]
 962 0754 08C093E5 		.loc 1 1850 0
 963 0758 0FE0A0E1 		mov	r2, r0
 964 075c 1CFF2FE1 		.loc 1 1853 0
 965 0760 000050E3 		movne	r3, r3, lsr #1
 966 0764 0600000A 		ldrneh	r2, [r0, #18]
 967              		subne	r3, r3, #2
 968 0768 0B30DDE5 		mulne	r2, r3, r2
 969 076c 0F0053E3 		.loc 1 1854 0
 970 0770 E6FFFF0A 		mov	r0, r2
1830:../Library/fat16.c **** /
1831:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1832:../Library/fat16.c ****                 break;
1833:../Library/fat16.c ****     
1834:../Library/fat16.c ****             dir_entry_offset += 32;
1835:../Library/fat16.c ****         }
 971              	49 0
 972 0774 0600A0E1 		@ lr needed for prologue
 973 0778 B212D7E1 		.loc 1 1854 0
 974 077c D1FEFFEB 		bx	lr
 975 0780 000000EA 	.LFE29:
 977              		.align	2
 978 0784 0000A0E3 		.global	fat16_get_fs_free
1836:../Library/fat16.c **** ntry */
1837:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1838:../Library/fat16.c ****                 break;
1839:../Library/fat16.c ****     
 980              	_fs_free:
 981 0788 0CD08DE2 	.LFB30:
 982 078c F040BDE8 		.loc 1 1867 0
 983 0790 1EFF2FE1 		@ Function supports interworking.
 984              		@ args = 0, pretend = 0, frame = 36
 985              		@ frame_needed = 0, uses_anonymous_args = 0
 986              	.LVL94:
 987              		stmfd	sp!, {r4, r5, r6, r7, lr}
 988              	.LCFI10:
 989              		.loc 1 1868 0
 990              		subs	r6, r0, #0
1840:../Library/fat16.c ****  
1841:../Library/fat16.c ****             /* check if we deleted the whole entry */
1842:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1843:../Library/fat16.c ****                 break;
1844:../Library/fat16.c ****     
1845:../Library/fat16.c ****             dir_entry_offset += 32;
1846:../Library/fat16.c ****         }
1847:../Library/fat16.c ****     
1848:../Library/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1849:../Library/fat16.c ****                              * marking all occupied clusters as free.
 991              	7 0
 992              		sub	sp, sp, #44
 993              	.LCFI11:
 994              		.loc 1 1868 0
 995              		beq	.L139
 996              	.LVL95:
1850:../Library/fat16.c **** he directory entry. The next thing to do is
 997              	1 1874 0
 998 0794 000050E3 		mov	r3, #32
1851:../Library/fat16.c ****          dir_entry_offset += 32;
1852:../Library/fat16.c ****         }
1853:../Library/fat16.c ****     
 999              	trb	r3, [sp, #42]
 1000 0798 0C309015 		.loc 1 1876 0
 1001              		ldr	r7, [r6, #8]
 1002 079c 0020A0E1 	.LVL96:
 1003              		.loc 1 1877 0
 1004 07a0 A330A011 		ldr	r5, [r6, #12]
 1005 07a4 B221D011 	.LVL97:
 1006 07a8 02304312 		.loc 1 1873 0
 1007 07ac 93020210 		mov	r3, #0	@ movhi
1854:../Library/fat16.c **** /
 1008              	 [sp, #40]	@ movhi
 1009 07b0 0200A0E1 		b	.L141
 1010              	.LVL98:
 1011              	.L142:
 1012              	.LBB20:
 1013              		.loc 1 1881 0
 1014 07b4 1EFF2FE1 		ldr	r3, .L150
 1015              		cmp	r5, r3
 1016              		.loc 1 1884 0
 1017              		ldr	r3, .L150+4
 1018              		.loc 1 1882 0
 1019              		movls	r4, r2, lsr #16
 1020              		.loc 1 1884 0
 1021              		ldr	ip, [r6, #0]
1855:../Library/fat16.c **** try_offset, buffer, sizeof(buffer)))
1856:../Library/fat16.c ****                 return 0;
1857:../Library/fat16.c ****     
1858:../Library/fat16.c ****             /* check if we deleted the whole entry */
1859:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1860:../Library/fat16.c ****                 break;
1861:../Library/fat16.c ****     
1862:../Library/fat16.c ****             dir_entry_offset += 32;
1863:../Library/fat16.c ****         }
1864:../Library/fat16.c ****     
1865:../Library/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1866:../Library/fat16.c ****                              * marking all occupied clusters as free.
1867:../Library/fat16.c ****                              */
 1022              	#0]
 1023              		add	r3, sp, #40
 1024              		str	r3, [sp, #4]
 1025              		mov	r0, r7
 1026              		add	r1, sp, #8
 1027 07b8 F0402DE9 		mov	r2, #32
 1028              		mov	r3, r4
1868:../Library/fat16.c **** g to do is
 1029              	, [ip, #4]
 1030 07bc 006050E2 		mov	lr, pc
 1031              		bx	ip
 1032 07c0 2CD04DE2 		cmp	r0, #0
 1033              		beq	.L139
 1034              		.loc 1 1895 0
 1035 07c4 2100000A 		rsb	r5, r4, r5
 1036              		.loc 1 1894 0
1869:../Library/fat16.c ****          dir_entry_offset += 32;
1870:../Library/fat16.c ****         }
1871:../Library/fat16.c ****     
1872:../Library/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1873:../Library/fat16.c ****                              * marking all occupied clusters as free.
1874:../Library/fat16.c ****                              */
 1037              	 r7, r4
 1038 07c8 2030A0E3 	.LVL99:
 1039 07cc 2A30CDE5 	.L141:
1875:../Library/fat16.c **** g to do is
1876:../Library/fat16.c ****                              * marking all occupied clusters as free.
 1040              	E20:
 1041 07d0 087096E5 		.loc 1 1878 0
 1042              		cmp	r5, #0
1877:../Library/fat16.c **** he directory entry. The next thing to do is
 1043              	B21:
 1044 07d4 0C5096E5 		.loc 1 1881 0
 1045              		ldr	r4, .L150+8
 1046              		.loc 1 1882 0
 1047 07d8 0030A0E3 		mov	r2, r5, asl #16
 1048 07dc B832CDE1 	.LBE21:
 1049 07e0 120000EA 		.loc 1 1878 0
 1050              		bne	.L142
 1051              		.loc 1 1898 0
 1052              		ldrh	r2, [r6, #18]
1878:../Library/fat16.c ****          dir_entry_offset += 32;
1879:../Library/fat16.c ****         }
1880:../Library/fat16.c ****     
1881:../Library/fat16.c ****         /* We deleted the directory entry. The next thing to do is
 1053              	[sp, #40]
 1054 07e4 74309FE5 		mul	r0, r2, r3
 1055 07e8 030055E1 		b	.L148
1882:../Library/fat16.c ****          dir_entry_offset += 32;
1883:../Library/fat16.c ****         }
1884:../Library/fat16.c ****     
 1056              	L100:
 1057 07ec 70309FE5 	.L139:
 1058              		mov	r0, #0
 1059 07f0 2248A091 	.L148:
 1060              		.loc 1 1899 0
 1061 07f4 00C096E5 		add	sp, sp, #44
 1062 07f8 00308DE5 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1063 07fc 28308DE2 		bx	lr
 1064 0800 04308DE5 	.L151:
 1065 0804 0700A0E1 		.align	2
 1066 0808 08108DE2 	.L150:
 1067 080c 2020A0E3 		.word	65533
 1068 0810 0430A0E1 		.word	fat16_get_fs_free_callback
 1069 0814 04C09CE5 		.word	65534
 1070 0818 0FE0A0E1 	.LFE30:
 1072 0820 000050E3 		.align	2
1885:../Library/fat16.c **** /
1886:../Library/fat16.c ****             if(buffer[11] != 0x0f)
1887:../Library/fat16.c ****                 break;
1888:../Library/fat16.c ****     
1889:../Library/fat16.c ****             dir_entry_offset += 32;
1890:../Library/fat16.c ****         }
1891:../Library/fat16.c ****     
1892:../Library/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1893:../Library/fat16.c ****                              * marking all occupied clusters as free.
1894:../Library/fat16.c ****                              */
1895:../Library/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1074              	callback:
 1075 0828 055064E0 	.LFB31:
 1076              		.loc 1 1906 0
 1077 082c 047087E0 		@ Function supports interworking.
 1078              		@ args = 0, pretend = 0, frame = 0
 1079              		@ frame_needed = 0, uses_anonymous_args = 0
 1080              	.LVL101:
 1081              		stmfd	sp!, {r4, lr}
 1082 0830 000055E3 	.LCFI12:
 1083              	.LVL102:
 1084              		.loc 1 1908 0
 1085 0834 2C409FE5 		ldrb	r4, [r2, #2]	@ zero_extendqisi2
 1086              	.LVL103:
 1087 0838 0528A0E1 	.LVL104:
 1088              		.loc 1 1906 0
 1089              		mov	ip, r2
 1090 083c E8FFFF1A 	.LVL105:
1896:../Library/fat16.c **** d clusters as free.
1897:../Library/fat16.c ****                              */
1898:../Library/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1091              	ov	r1, r0
 1092 0840 B221D6E1 	.LVL106:
 1093 0844 B832DDE1 		mov	lr, #0
 1094 0848 920300E0 		b	.L159
 1095 084c 000000EA 	.L154:
 1096              		.loc 1 1912 0
 1097              		ldrb	r3, [lr, r0]	@ zero_extendqisi2
 1098 0850 0000A0E3 		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 1099              	.LVL107:
1899:../Library/fat16.c **** d clusters as free.
 1100              	 r3, r2, asl #8
 1101 0854 2CD08DE2 		.loc 1 1913 0
 1102 0858 F040BDE8 		ldreqh	r3, [ip, #0]
 1103 085c 1EFF2FE1 		addeq	r3, r3, #1
 1104              		streqh	r3, [ip, #0]	@ movhi
 1105              		.loc 1 1915 0
 1106              		add	r1, r1, #2
 1107 0860 FDFF0000 		add	lr, lr, #2
 1108 0864 00000000 	.LVL108:
 1109 0868 FEFF0000 	.L159:
 1110              		.loc 1 1910 0
 1111              		and	r3, lr, #255
 1112              		cmp	r3, r4
 1113              		bcc	.L154
 1114              		.loc 1 1919 0
 1115              		mov	r0, #1
1900:../Library/fat16.c **** he directory entry. The next thing to do is
1901:../Library/fat16.c ****                              * marking all occupied clusters as free.
1902:../Library/fat16.c ****                              */
1903:../Library/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1904:../Library/fat16.c ****     #else
1905:../Library/fat16.c ****         return 0;
1906:../Library/fat16.c ****     #endif
 1116              	sp!, {r4, lr}
 1117              		bx	lr
 1118              	.LFE31:
 1120              		.align	2
 1121 086c 10402DE9 		.global	fat16_file_size
 1123              	fat16_file_size:
1907:../Library/fat16.c ****        */
1908:../Library/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1124              		.loc 1 1945 0
 1125 0870 0240D2E5 		@ Function supports interworking.
 1126              		@ args = 0, pretend = 0, frame = 0
 1127              		@ frame_needed = 0, uses_anonymous_args = 0
 1128              		@ link register save eliminated.
 1129 0874 02C0A0E1 	.LVL110:
 1130              		.loc 1 1947 0
 1131              		ldr	r0, [r0, #40]
 1132 0878 0010A0E1 	.LVL111:
 1133              		.loc 1 1945 0
 1134 087c 00E0A0E3 		@ lr needed for prologue
 1135 0880 070000EA 		.loc 1 1947 0
 1136              		bx	lr
1909:../Library/fat16.c **** d clusters as free.
1910:../Library/fat16.c ****                              */
1911:../Library/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1912:../Library/fat16.c ****     #else
 1137              	e	fat16_file_size, .-fat16_file_size
 1138 0884 0030DEE7 		.align	2
 1139 0888 0120D1E5 		.global	fat16_read_dir
 1141 088c 022493E1 	fat16_read_dir:
1913:../Library/fat16.c **** as free.
 1142              	3:
 1143 0890 B030DC01 		.loc 1 1390 0
 1144 0894 01308302 		@ Function supports interworking.
 1145 0898 B030CC01 		@ args = 0, pretend = 0, frame = 48
1914:../Library/fat16.c **** he directory entry. The next thing to do is
1915:../Library/fat16.c ****                              * marking all occupied clusters as free.
 1146              	rame_needed = 0, uses_anonymous_args = 0
 1147 089c 021081E2 	.LVL112:
 1148 08a0 02E08EE2 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1149              	.LCFI13:
 1150              		.loc 1 1391 0
 1151              		mov	sl, r1
 1152 08a4 FF300EE2 		rsbs	r1, r1, #1
 1153 08a8 040053E1 		movcc	r1, #0
 1154 08ac F4FFFF3A 	.LVL113:
1916:../Library/fat16.c **** he directory entry. The next thing to do is
1917:../Library/fat16.c ****                              * marking all occupied clusters as free.
1918:../Library/fat16.c ****                              */
1919:../Library/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1155              	#0
 1156 08b0 0100A0E3 		cmpne	r0, #0
 1157              		.loc 1 1390 0
 1158 08b4 1040BDE8 		sub	sp, sp, #56
 1159 08b8 1EFF2FE1 	.LCFI14:
 1160              		.loc 1 1391 0
 1161              		mov	r8, r0
 1162              		beq	.L184
 1163              	.LVL114:
 1164              		.loc 1 1394 0
 1165              		ldrh	r3, [r0, #38]
 1166              		cmp	r3, #0
1920:../Library/fat16.c **** d clusters as free.
1921:../Library/fat16.c ****                              */
1922:../Library/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1923:../Library/fat16.c ****     #else
1924:../Library/fat16.c ****         return 0;
1925:../Library/fat16.c ****     #endif
1926:../Library/fat16.c **** }
1927:../Library/fat16.c **** 
1928:../Library/fat16.c **** /**
1929:../Library/fat16.c ****  * \ingroup fat16_fs
1930:../Library/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
1931:../Library/fat16.c ****  *
1932:../Library/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1933:../Library/fat16.c ****  * \returns 0 on failure, the filesystem size in bytes otherwise.
1934:../Library/fat16.c ****  */
1935:../Library/fat16.c **** uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
1936:../Library/fat16.c **** {
1937:../Library/fat16.c ****     if(!fs)
1938:../Library/fat16.c ****         return 0;
1939:../Library/fat16.c **** 
1940:../Library/fat16.c ****     return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
1941:../Library/fat16.c **** }
1942:../Library/fat16.c **** 
1943:../Library/fat16.c **** /**
1944:../Library/fat16.c ****  * \ingroup fat16_fs
1945:../Library/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
 1167              	0, #48]
 1168              		ldr	r6, [r0, #0]
 1169              		bne	.L166
 1170              	.LVL115:
 1171              	.LBB26:
 1172              		.loc 1 358 0
1946:../Library/fat16.c **** roup fat16_fs
1947:../Library/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
 1173              	6, #0
 1174 08bc 280090E5 		movne	r7, r1
 1175              		orreq	r7, r1, #1
 1176              		cmp	r7, #0
 1177              		bne	.L168
 1178              	.LBB27:
 1179 08c0 1EFF2FE1 		.loc 1 363 0
 1180              		ldr	r3, [r6, #0]
 1181              		.loc 1 368 0
 1182              		add	r5, sp, #44
 1183              		.loc 1 362 0
 1184              		add	r4, r6, #4
 1185              	.LVL116:
 1186              		.loc 1 368 0
 1187              		mov	r1, r7
 1188              		mov	r2, #12
 1189              		mov	r0, r5
 1190              	.LVL117:
 1191              		.loc 1 363 0
 1192 08c4 F04F2DE9 		ldr	r6, [r3, #4]
 1193              	.LVL118:
 1194              		.loc 1 368 0
 1195 08c8 01A0A0E1 		bl	memset
 1196 08cc 011071E2 	.LBE27:
 1197 08d0 0010A033 		.loc 1 370 0
 1198              	.LBB28:
 1199 08d4 00005AE3 		add	r0, r4, #16
 1200 08d8 00005013 		ldmia	r0, {r0, r3}	@ phole ldm
 1201              	.LBE28:
 1202 08dc 38D04DE2 		ldr	r2, .L188
 1203              		rsb	r3, r0, r3
 1204              		mov	r3, r3, asl #16
 1205 08e0 0080A0E1 		add	r4, sp, #12
 1206 08e4 7600000A 	.LVL119:
 1207              		str	r2, [sp, #0]
 1208              	.LBB29:
 1209 08e8 B632D0E1 		.loc 1 369 0
 1210 08ec 000053E3 		strh	r9, [sp, #46]	@ movhi
 1211 08f0 B093D0E1 	.LBE29:
 1212 08f4 006090E5 		.loc 1 370 0
 1213 08f8 2C00001A 		str	r5, [sp, #4]
 1214              		mov	r3, r3, lsr #16
 1215              		mov	r1, r4
 1216              		mov	r2, #32
 1217 08fc 000056E3 		mov	lr, pc
 1218 0900 0170A011 		bx	r6
 1219 0904 01708103 	.LBB30:
 1220 0908 000057E3 		cmp	r0, #0
 1221 090c 6A00001A 		beq	.L168
 1222              		ldr	r3, [sp, #48]
 1223              		cmp	r3, #0
 1224 0910 003096E5 		beq	.L168
 1225              		.loc 1 381 0
 1226 0914 2C508DE2 		mov	r1, r7
 1227              		mov	r2, #44
 1228 0918 044086E2 		mov	r0, sl
 1229              		bl	memset
 1230              	.LBE30:
 1231 091c 0710A0E1 		.loc 1 382 0
 1232 0920 0C20A0E3 		ldr	r2, .L188+4
 1233 0924 0500A0E1 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 1234              		stmia	sp, {r2, sl}	@ phole stm
 1235              		mov	r1, r4
 1236 0928 046093E5 		ldr	r0, [sp, #48]
 1237              		mov	r2, #32
 1238              		mov	lr, pc
 1239 092c FEFFFFEB 		bx	r6
 1240              		b	.L187
 1241              	.LVL120:
 1242              	.L166:
 1243 0930 100084E2 	.LBE26:
 1244 0934 090090E8 	.LBB31:
 1245              	.LBB32:
 1246 0938 94219FE5 		.loc 1 406 0
 1247 093c 033060E0 		cmp	r6, #0
 1248 0940 0338A0E1 	.LBE32:
 1249 0944 0C408DE2 	.LBE31:
 1250              		.loc 1 1400 0
 1251 0948 00208DE5 		str	r9, [sp, #8]
 1252              	.LVL121:
 1253              	.LBB33:
 1254 094c BE92CDE1 	.LBB34:
 1255              		.loc 1 406 0
 1256              		beq	.L168
 1257 0950 04508DE5 		cmp	r1, #0
 1258 0954 2338A0E1 		bne	.L168
 1259 0958 0410A0E1 		add	r0, r0, #4
 1260 095c 2020A0E3 	.LVL122:
 1261 0960 0FE0A0E1 		.loc 1 410 0
 1262 0964 16FF2FE1 		ldrb	r3, [r0, #32]	@ zero_extendqisi2
 1263              		tst	r3, #16
 1264 0968 000050E3 		beq	.L168
 1265 096c 5200000A 		.loc 1 417 0
 1266 0970 30309DE5 		ldrh	r7, [r0, #34]
 1267 0974 000053E3 	.LVL123:
 1268 0978 4F00000A 		.loc 1 416 0
 1269              		ldrh	r9, [r6, #18]
 1270 097c 0710A0E1 	.LVL124:
 1271 0980 2C20A0E3 	.LVL125:
 1272 0984 0A00A0E1 	.L177:
 1273 0988 FEFFFFEB 		.loc 1 423 0
 1274              		ldr	r2, [r6, #24]
 1275              		sub	r3, r7, #2
 1276 098c 44219FE5 		mla	r5, r9, r3, r2
 1277 0990 3430DDE5 		.loc 1 426 0
 1278 0994 04048DE8 		add	r4, sp, #44
 1279 0998 0410A0E1 		mov	r1, #0
 1280 099c 30009DE5 		mov	r2, #12
 1281 09a0 2020A0E3 		mov	r0, r4
 1282 09a4 0FE0A0E1 	.LVL126:
 1283 09a8 16FF2FE1 		bl	memset
 1284 09ac 390000EA 		.loc 1 427 0
 1285              		ldr	r3, [sp, #8]
 1286              		strh	r3, [sp, #46]	@ movhi
 1287              	.LBE34:
 1288              		.loc 1 428 0
 1289              		ldr	r3, .L188
 1290              		add	fp, sp, #12
 1291 09b0 000056E3 		ldr	ip, [r6, #0]
 1292              		mov	r1, fp
 1293              		str	r3, [sp, #0]
 1294              		mov	r0, r5
 1295 09b4 08908DE5 		str	r4, [sp, #4]
 1296              		mov	r2, #32
 1297              		mov	r3, r9
 1298              		ldr	ip, [ip, #4]
 1299              		mov	lr, pc
 1300 09b8 3F00000A 		bx	ip
 1301 09bc 000051E3 	.LBB35:
 1302 09c0 3D00001A 		cmp	r0, #0
 1303 09c4 040080E2 	.LBE35:
 1304              		.loc 1 442 0
 1305              		mov	r1, r7
 1306 09c8 2030D0E5 		mov	r0, r6
 1307 09cc 100013E3 	.LVL127:
 1308 09d0 3900000A 	.LBB36:
 1309              		.loc 1 428 0
 1310 09d4 B272D0E1 		beq	.L168
 1311              		.loc 1 438 0
 1312              		ldr	r3, [sp, #48]
 1313 09d8 B291D6E1 		cmp	r3, #0
 1314              		bne	.L179
 1315              	.LBE36:
 1316              		.loc 1 442 0
 1317              		bl	fat16_get_next_cluster
 1318 09dc 182096E5 	.LVL128:
 1319 09e0 023047E2 	.LBB37:
 1320 09e4 992325E0 		subs	r7, r0, #0
 1321              		beq	.L168
 1322 09e8 2C408DE2 		b	.L177
 1323 09ec 0010A0E3 	.LVL129:
 1324 09f0 0C20A0E3 	.L179:
 1325 09f4 0400A0E1 		.loc 1 446 0
 1326              		mov	r1, #0
 1327 09f8 FEFFFFEB 		mov	r2, #44
 1328              		mov	r0, sl
 1329 09fc 08309DE5 	.LVL130:
 1330 0a00 BE32CDE1 		bl	memset
 1331              	.LBE37:
 1332              		.loc 1 449 0
 1333 0a04 C8309FE5 		ldr	r2, .L188+4
 1334 0a08 0CB08DE2 		ldr	ip, [r6, #0]
 1335 0a0c 00C096E5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 1336 0a10 0B10A0E1 		stmia	sp, {r2, sl}	@ phole stm
 1337 0a14 00308DE5 		mov	r1, fp
 1338 0a18 0500A0E1 		ldr	r0, [sp, #48]
 1339 0a1c 04408DE5 		mov	r2, #32
 1340 0a20 2020A0E3 		ldr	ip, [ip, #4]
 1341 0a24 0930A0E1 		mov	lr, pc
 1342 0a28 04C09CE5 		bx	ip
 1343 0a2c 0FE0A0E1 	.LVL131:
 1344 0a30 1CFF2FE1 	.L187:
 1345              	.LBB38:
 1346 0a34 000050E3 		cmp	r0, #0
 1347              		beq	.L168
 1348              	.LBE38:
 1349 0a38 0710A0E1 	.LBE33:
 1350 0a3c 0600A0E1 		.loc 1 1406 0
 1351              		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 1352              		cmp	r3, #0
 1353              		.loc 1 1408 0
 1354 0a40 1D00000A 		ldrneh	r3, [r8, #48]
 1355              		movne	r0, #1
 1356 0a44 30309DE5 		addne	r3, r3, #1
 1357 0a48 000053E3 		strneh	r3, [r8, #48]	@ movhi
 1358 0a4c 0300001A 		bne	.L165
 1359              	.LVL132:
 1360              	.L168:
 1361 0a50 F2FDFFEB 		.loc 1 1414 0
 1362              		mov	r3, #0	@ movhi
 1363              		strh	r3, [r8, #48]	@ movhi
 1364 0a54 007050E2 	.L184:
 1365 0a58 1700000A 		mov	r0, #0
 1366 0a5c DEFFFFEA 	.LVL133:
 1367              	.L165:
 1368              		.loc 1 1417 0
 1369              		add	sp, sp, #56
 1370 0a60 0010A0E3 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1371 0a64 2C20A0E3 		bx	lr
 1372 0a68 0A00A0E1 	.L189:
 1373              		.align	2
 1374 0a6c FEFFFFEB 	.L188:
 1375              		.word	fat16_dir_entry_seek_callback
 1376              		.word	fat16_dir_entry_read_callback
 1377 0a70 60209FE5 	.LFE23:
 1379 0a78 3430DDE5 		.align	2
 1380 0a7c 04048DE8 		.global	find_file_in_dir
 1382 0a84 30009DE5 	find_file_in_dir:
 1383 0a88 2020A0E3 	.LFB32:
 1384 0a8c 04C09CE5 		.loc 1 1922 0
 1385 0a90 0FE0A0E1 		@ Function supports interworking.
 1386 0a94 1CFF2FE1 		@ args = 0, pretend = 0, frame = 0
 1387              		@ frame_needed = 0, uses_anonymous_args = 0
 1388              	.LVL134:
 1389              		stmfd	sp!, {r4, r5, r6, lr}
 1390 0a98 000050E3 	.LCFI15:
 1391 0a9c 0600000A 		.loc 1 1922 0
 1392              		mov	r4, r1
 1393              		mov	r6, r2
 1394              		mov	r5, r3
 1395 0aa0 0030DAE5 		b	.L191
 1396 0aa4 000053E3 	.LVL135:
 1397              	.L192:
 1398 0aa8 B033D811 		.loc 1 1925 0
 1399 0aac 0100A013 		bl	strcmp
 1400 0ab0 01308312 	.LVL136:
 1401 0ab4 B033C811 		cmp	r0, #0
 1402 0ab8 0200001A 		bne	.L191
 1403              	.LBB39:
 1404              	.LBB40:
 1405              		.loc 1 1432 0
 1406 0abc 0030A0E3 		cmp	r4, #0
 1407 0ac0 B033C8E1 		moveq	r3, #1
 1408              		.loc 1 1435 0
 1409 0ac4 0000A0E3 		movne	r3, #1
 1410              		strneh	r0, [r4, #48]	@ movhi
 1411              		b	.L196
 1412              	.LVL137:
 1413 0ac8 38D08DE2 	.L191:
 1414 0acc F04FBDE8 	.LBE40:
 1415 0ad0 1EFF2FE1 	.LBE39:
 1416              		.loc 1 1923 0
 1417              		mov	r1, r5
 1418              		mov	r0, r4
 1419 0ad4 00000000 	.LVL138:
 1420 0ad8 00000000 		bl	fat16_read_dir
 1421              		subs	r3, r0, #0
 1422              		.loc 1 1925 0
 1423              		mov	r1, r6
 1424              		mov	r0, r5
 1425              		.loc 1 1923 0
 1426              		bne	.L192
 1427              	.L196:
 1428              		.loc 1 1933 0
 1429              		mov	r0, r3
 1430              		ldmfd	sp!, {r4, r5, r6, lr}
 1431              		bx	lr
 1432              	.LFE32:
 1434              		.global	__divsi3
 1435              		.align	2
 1437 0ae4 0260A0E1 	fat16_write_dir_entry:
 1438 0ae8 0350A0E1 	.LFB26:
 1439 0aec 070000EA 		.loc 1 1468 0
 1440              		@ Function supports interworking.
 1441              		@ args = 0, pretend = 0, frame = 32
 1442              		@ frame_needed = 0, uses_anonymous_args = 0
 1443 0af0 FEFFFFEB 	.LVL139:
 1444              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1445 0af4 000050E3 	.LCFI16:
 1446 0af8 0400001A 		.loc 1 1470 0
 1447              		cmp	r1, #0
 1448              		cmpne	r0, #0
 1449              		.loc 1 1468 0
 1450 0afc 000054E3 		sub	sp, sp, #32
 1451 0b00 0130A003 	.LCFI17:
 1452              		.loc 1 1470 0
 1453 0b04 0130A013 		mov	r6, r1
 1454 0b08 B003C411 		beq	.L202
 1455 0b0c 060000EA 	.LVL140:
 1456              		.loc 1 1473 0
 1457              		ldr	r3, [r0, #0]
 1458              		.loc 1 1475 0
 1459              		mov	r0, r1
 1460              	.LVL141:
 1461 0b10 0510A0E1 		.loc 1 1473 0
 1462 0b14 0400A0E1 		ldr	r9, [r3, #8]
 1463              	.LVL142:
 1464 0b18 FEFFFFEB 		.loc 1 1475 0
 1465 0b1c 003050E2 		bl	strlen
 1466              		and	r5, r0, #255
 1467 0b20 0610A0E1 	.LVL143:
 1468 0b24 0500A0E1 		.loc 1 1476 0
 1469              		mov	r1, #13
 1470 0b28 F0FFFF1A 		add	r0, r5, #12
 1471              		bl	__divsi3
 1472              		.loc 1 1482 0
 1473 0b2c 0300A0E1 		mov	r1, #32
 1474 0b30 7040BDE8 		.loc 1 1476 0
 1475 0b34 1EFF2FE1 		mov	r3, r0
 1476              		.loc 1 1482 0
 1477              		mov	r2, #11
 1478              		mov	r0, sp
 1479              		.loc 1 1476 0
 1480              		and	sl, r3, #255
 1481              	.LVL144:
 1482              		.loc 1 1474 0
 1483              		ldr	r8, [r6, #40]
 1484              	.LVL145:
 1485              		.loc 1 1482 0
 1486              		bl	memset
 1487              		.loc 1 1483 0
 1488 0b38 F0472DE9 		mov	r0, r6
 1489              		mov	r1, #46
 1490              		bl	strrchr
 1491 0b3c 000051E3 		.loc 1 1484 0
 1492 0b40 00005013 		cmp	r0, #0
 1493              		.loc 1 1482 0
 1494 0b44 20D04DE2 		mov	r7, sp
 1495              		.loc 1 1484 0
 1496              		beq	.L204
 1497 0b48 0160A0E1 	.LBB41:
 1498 0b4c 9800000A 		.loc 1 1486 0
 1499              		add	r4, r0, #1
 1500              	.LVL146:
 1501 0b50 003090E5 		.loc 1 1488 0
 1502              		mov	r0, r4
 1503 0b54 0100A0E1 		bl	strlen
 1504              		and	r2, r0, #255
 1505              	.LVL147:
 1506 0b58 089093E5 		.loc 1 1489 0
 1507              		rsb	r3, r2, r5
 1508              		sub	r3, r3, #1
 1509 0b5c FEFFFFEB 		.loc 1 1494 0
 1510 0b60 FF5000E2 		cmp	r2, #3
 1511              		movcs	r2, #3
 1512              	.LVL148:
 1513 0b64 0D10A0E3 		mov	r1, r4
 1514 0b68 0C0085E2 		add	r0, sp, #8
 1515 0b6c FEFFFFEB 		.loc 1 1489 0
 1516              		and	r5, r3, #255
 1517 0b70 2010A0E3 		.loc 1 1494 0
 1518              		bl	memcpy
 1519 0b74 0030A0E1 	.L204:
 1520              	.LBE41:
 1521 0b78 0B20A0E3 		.loc 1 1497 0
 1522 0b7c 0D00A0E1 		cmp	r5, #8
 1523              		bhi	.L206
 1524 0b80 FFA003E2 		.loc 1 1499 0
 1525              		mov	r0, sp
 1526              		mov	r2, r5
 1527 0b84 288096E5 		mov	r1, r6
 1528              		bl	memcpy
 1529              		b	.L208
 1530 0b88 FEFFFFEB 	.L206:
 1531              	.LBB42:
 1532 0b8c 0600A0E1 		.loc 1 1503 0
 1533 0b90 2E10A0E3 		mov	r2, #8
 1534 0b94 FEFFFFEB 		mov	r0, sp
 1535              		mov	r1, r6
 1536 0b98 000050E3 		bl	memcpy
 1537              		.loc 1 1508 0
 1538 0b9c 0D70A0E1 		ldrb	r3, [r6, #34]	@ zero_extendqisi2
 1539              	.LVL149:
 1540 0ba0 0B00000A 		.loc 1 1510 0
 1541              		cmp	r3, #159
 1542              		mov	r2, r3, lsr #4
 1543 0ba4 014080E2 		.loc 1 1511 0
 1544              		and	r3, r3, #15
 1545              	.LVL150:
 1546 0ba8 0400A0E1 		.loc 1 1510 0
 1547 0bac FEFFFFEB 		addls	r2, r2, #48
 1548 0bb0 FF2000E2 		addhi	r2, r2, #97
 1549              		.loc 1 1512 0
 1550              		cmp	r3, #9
 1551 0bb4 053062E0 		addls	r3, r3, #48
 1552 0bb8 013043E2 	.LVL151:
 1553              		addhi	r3, r3, #97
 1554 0bbc 030052E3 	.LVL152:
 1555 0bc0 0320A023 		.loc 1 1510 0
 1556              		strb	r2, [sp, #6]
 1557 0bc4 0410A0E1 		.loc 1 1512 0
 1558 0bc8 08008DE2 		strb	r3, [sp, #7]
 1559              	.L208:
 1560 0bcc FF5003E2 	.LBE42:
 1561              		.loc 1 1516 0
 1562 0bd0 FEFFFFEB 		mov	r1, #0
 1563              		mov	r2, #21
 1564              		add	r0, sp, #11
 1565              		bl	memset
 1566 0bd4 080055E3 		.loc 1 1517 0
 1567 0bd8 0400008A 		ldrb	r3, [r6, #32]	@ zero_extendqisi2
 1568              		strb	r3, [sp, #11]
 1569 0bdc 0D00A0E1 		.loc 1 1572 0
 1570 0be0 0520A0E1 		ldrh	r2, [r6, #34]
 1571 0be4 0610A0E1 		.loc 1 1573 0
 1572 0be8 FEFFFFEB 		mov	r3, r2, lsr #8
 1573 0bec 0E0000EA 		.loc 1 1572 0
 1574              		strb	r2, [sp, #26]
 1575              		.loc 1 1573 0
 1576              		strb	r3, [sp, #27]
 1577 0bf0 0820A0E3 		.loc 1 1574 0
 1578 0bf4 0D00A0E1 		ldr	r3, [r6, #36]
 1579 0bf8 0610A0E1 		.loc 1 1577 0
 1580 0bfc FEFFFFEB 		mov	r0, r3, lsr #24
 1581              		.loc 1 1575 0
 1582 0c00 2230D6E5 		mov	r2, r3, lsr #8
 1583              		.loc 1 1576 0
 1584              		mov	r1, r3, lsr #16
 1585 0c04 9F0053E3 		.loc 1 1575 0
 1586 0c08 2322A0E1 		strb	r2, [sp, #29]
 1587              		.loc 1 1576 0
 1588 0c0c 0F3003E2 		strb	r1, [sp, #30]
 1589              		.loc 1 1577 0
 1590              		strb	r0, [sp, #31]
 1591 0c10 30208292 		.loc 1 1574 0
 1592 0c14 61208282 		strb	r3, [sp, #28]
 1593              		.loc 1 1580 0
 1594 0c18 090053E3 		add	r0, r8, sl, asl #5
 1595 0c1c 30308392 		mov	r1, sp
 1596              		mov	r2, #32
 1597 0c20 61308382 		mov	lr, pc
 1598              		bx	r9
 1599              		cmp	r0, #0
 1600 0c24 0620CDE5 		.loc 1 1516 0
 1601              		mov	r4, sp
 1602 0c28 0730CDE5 	.LVL153:
 1603              		.loc 1 1580 0
 1604              		beq	.L202
 1605              		.loc 1 1584 0
 1606 0c2c 0010A0E3 		ldrb	r7, [sp, #0]	@ zero_extendqisi2
 1607 0c30 1520A0E3 	.LVL154:
 1608 0c34 0B008DE2 		mov	r1, sp
 1609 0c38 FEFFFFEB 	.L216:
 1610              		.loc 1 1587 0
 1611 0c3c 2030D6E5 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 1612 0c40 0B30CDE5 		mov	r3, r7, asl #7
 1613              		orr	r3, r3, r7, lsr #1
 1614 0c44 B222D6E1 		add	r3, r3, r2
 1615              		.loc 1 1586 0
 1616 0c48 2234A0E1 		add	r2, sp, #10
 1617              		cmp	r1, r2
 1618 0c4c 1A20CDE5 		.loc 1 1587 0
 1619              		and	r7, r3, #255
 1620 0c50 1B30CDE5 		.loc 1 1586 0
 1621              		bne	.L216
 1622 0c54 243096E5 		mov	r5, sl
 1623              	.LVL155:
 1624 0c58 230CA0E1 		b	.L218
 1625              	.L219:
 1626 0c5c 2324A0E1 	.LBB43:
 1627              		.loc 1 1593 0
 1628 0c60 2318A0E1 		mov	r1, #0
 1629              		mov	r2, #32
 1630 0c64 1D20CDE5 		mov	r0, sp
 1631              		bl	memset
 1632 0c68 1E10CDE5 		.loc 1 1594 0
 1633              		mov	r1, #255
 1634 0c6c 1F00CDE5 		mov	r2, #10
 1635              		add	r0, sp, #1
 1636 0c70 1C30CDE5 		bl	memset
 1637              		.loc 1 1595 0
 1638 0c74 8A0288E0 		mov	r1, #255
 1639 0c78 0D10A0E1 		mov	r2, #12
 1640 0c7c 2020A0E3 		add	r0, sp, #14
 1641 0c80 0FE0A0E1 		bl	memset
 1642 0c84 19FF2FE1 		.loc 1 1596 0
 1643 0c88 000050E3 		add	r0, sp, #28
 1644              		mov	r1, #255
 1645 0c8c 0D40A0E1 		mov	r2, #4
 1646              		bl	memset
 1647              		.loc 1 1599 0
 1648 0c90 4700000A 		cmp	r5, sl
 1649              		.loc 1 1600 0
 1650 0c94 0070DDE5 		orreq	r3, r5, #64
 1651              		.loc 1 1598 0
 1652 0c98 0D10A0E1 		strb	r5, [sp, #0]
 1653              		.loc 1 1600 0
 1654              		streqb	r3, [sp, #0]
 1655 0c9c 0120F1E5 		mov	r3, #13
 1656 0ca0 8733A0E1 		mla	lr, r5, r3, r6
 1657 0ca4 A73083E1 		mov	ip, #1
 1658 0ca8 023083E0 	.LVL156:
 1659              	.L222:
 1660 0cac 0A208DE2 		.loc 1 1607 0
 1661 0cb0 020051E1 		add	r3, ip, #1
 1662              		and	r3, r3, #255
 1663 0cb4 FF7003E2 	.LVL157:
 1664              		.loc 1 1608 0
 1665 0cb8 F7FFFF1A 		add	r2, r3, #1
 1666 0cbc 0A50A0E1 		.loc 1 1607 0
 1667              		add	r4, sp, #32
 1668 0cc0 370000EA 		ldrb	r0, [lr, #-13]	@ zero_extendqisi2
 1669              		add	r1, r4, ip
 1670              		.loc 1 1608 0
 1671              		and	ip, r2, #255
 1672 0cc4 0010A0E3 		.loc 1 1610 0
 1673 0cc8 2020A0E3 		cmp	ip, #11
 1674 0ccc 0D00A0E1 		.loc 1 1608 0
 1675 0cd0 FEFFFFEB 		add	r2, r4, r3
 1676              		mov	r3, #0
 1677 0cd4 FF10A0E3 	.LVL158:
 1678 0cd8 0A20A0E3 		.loc 1 1607 0
 1679 0cdc 01008DE2 		strb	r0, [r1, #-32]
 1680 0ce0 FEFFFFEB 		.loc 1 1610 0
 1681              		moveq	ip, #14
 1682 0ce4 FF10A0E3 		.loc 1 1608 0
 1683 0ce8 0C20A0E3 		strb	r3, [r2, #-32]
 1684 0cec 0E008DE2 		.loc 1 1610 0
 1685 0cf0 FEFFFFEB 		beq	.L223
 1686              		cmp	ip, #26
 1687 0cf4 1C008DE2 		addeq	ip, ip, #2
 1688 0cf8 FF10A0E3 	.L223:
 1689 0cfc 0420A0E3 		.loc 1 1620 0
 1690 0d00 FEFFFFEB 		ldrb	r3, [lr, #-13]	@ zero_extendqisi2
 1691              		cmp	r3, #0
 1692 0d04 0A0055E1 		.loc 1 1621 0
 1693              		add	lr, lr, #1
 1694 0d08 40308503 		.loc 1 1620 0
 1695              		beq	.L226
 1696 0d0c 0050CDE5 		.loc 1 1605 0
 1697              		cmp	ip, #30
 1698 0d10 0030CD05 		bls	.L222
 1699 0d14 0D30A0E3 	.L226:
 1700 0d18 95632EE0 		.loc 1 1625 0
 1701 0d1c 01C0A0E3 		mov	r3, #15
 1702              		strb	r3, [sp, #11]
 1703              		.loc 1 1631 0
 1704              		mov	r0, r8
 1705 0d20 01308CE2 		.loc 1 1628 0
 1706 0d24 FF3003E2 		strb	r7, [sp, #13]
 1707              		.loc 1 1631 0
 1708              		mov	r1, sp
 1709 0d28 012083E2 		mov	r2, #32
 1710              		mov	lr, pc
 1711 0d2c 20408DE2 		bx	r9
 1712 0d30 0D005EE5 	.LVL159:
 1713 0d34 0C1084E0 	.LBE43:
 1714              		.loc 1 1591 0
 1715 0d38 FFC002E2 		sub	r3, r5, #1
 1716              	.LBB44:
 1717 0d3c 0B005CE3 		.loc 1 1633 0
 1718              		add	r8, r8, #32
 1719 0d40 032084E0 	.LBE44:
 1720 0d44 0030A0E3 		.loc 1 1591 0
 1721              		and	r5, r3, #255
 1722              	.L218:
 1723 0d48 200041E5 		cmp	r5, #0
 1724              		bne	.L219
 1725 0d4c 0EC0A003 		mov	r0, #1
 1726              		b	.L229
 1727 0d50 203042E5 	.LVL160:
 1728              	.L202:
 1729 0d54 0100000A 		mov	r0, #0
 1730 0d58 1A005CE3 	.LVL161:
 1731 0d5c 02C08C02 	.L229:
 1732              		.loc 1 1641 0
 1733              		add	sp, sp, #32
 1734 0d60 0D305EE5 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1735 0d64 000053E3 		bx	lr
 1736              	.LFE26:
 1738              		.global	__udivsi3
 1739 0d6c 0100000A 		.align	2
 1740              		.global	fat16_resize_file
 1742 0d74 E9FFFF9A 	fat16_resize_file:
 1743              	.LFB20:
 1744              		.loc 1 1254 0
 1745 0d78 0F30A0E3 		@ Function supports interworking.
 1746 0d7c 0B30CDE5 		@ args = 0, pretend = 0, frame = 4
 1747              		@ frame_needed = 0, uses_anonymous_args = 0
 1748 0d80 0800A0E1 	.LVL162:
 1749              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1750 0d84 0D70CDE5 	.LCFI18:
 1751              		.loc 1 1256 0
 1752 0d88 0D10A0E1 		subs	r6, r0, #0
 1753 0d8c 2020A0E3 		.loc 1 1254 0
 1754 0d90 0FE0A0E1 		sub	sp, sp, #4
 1755 0d94 19FF2FE1 	.LCFI19:
 1756              		.loc 1 1254 0
 1757              		mov	sl, r1
 1758              		.loc 1 1256 0
 1759 0d98 013045E2 		beq	.L235
 1760              	.LVL163:
 1761              		.loc 1 1259 0
 1762 0d9c 208088E2 		ldrh	r4, [r6, #38]
 1763              	.LVL164:
 1764              		.loc 1 1260 0
 1765 0da0 FF5003E2 		ldr	r3, [r6, #0]
 1766              		.loc 1 1265 0
 1767 0da4 000055E3 		rsbs	r9, r1, #1
 1768 0da8 C5FFFF1A 		movcc	r9, #0
 1769 0dac 0100A0E3 		cmp	r4, #0
 1770 0db0 000000EA 		cmpeq	r1, #0
 1771              		.loc 1 1260 0
 1772              		ldrh	r8, [r3, #18]
 1773 0db4 0000A0E3 	.LVL165:
 1774              		.loc 1 1267 0
 1775              		movne	r7, r1
 1776              	.LVL166:
 1777 0db8 20D08DE2 		.loc 1 1265 0
 1778 0dbc F047BDE8 		bne	.L239
 1779 0dc0 1EFF2FE1 	.LVL167:
 1780              		b	.L237
 1781              	.LVL168:
 1782              	.L240:
 1783              	.LBB49:
 1784              		.loc 1 1273 0
 1785              		ldr	r0, [r6, #0]
 1786              		bl	fat16_get_next_cluster
 1787              	.LVL169:
 1788              		.loc 1 1274 0
 1789              		cmp	r0, #0
 1790              		beq	.L241
 1791              		.loc 1 1281 0
 1792              		rsb	r7, r8, r7
 1793 0dc4 F0472DE9 		mov	r4, r0
 1794              	.LVL170:
 1795              	.L239:
 1796 0dc8 006050E2 	.LBE49:
 1797              		.loc 1 1270 0
 1798 0dcc 04D04DE2 		cmp	r7, r8
 1799              	.LBB50:
 1800              		.loc 1 1273 0
 1801 0dd0 01A0A0E1 		mov	r1, r4
 1802              	.LBE50:
 1803 0dd4 5B00000A 		.loc 1 1270 0
 1804              		bhi	.L240
 1805              	.LVL171:
 1806 0dd8 B642D6E1 		.loc 1 1285 0
 1807              		rsbs	r5, r4, #1
 1808              		movcc	r5, #0
 1809 0ddc 003096E5 		cmp	r5, #0
 1810              		beq	.L244
 1811 0de0 019071E2 	.LVL172:
 1812 0de4 0090A033 	.L245:
 1813 0de8 000054E3 	.LBB51:
 1814 0dec 00005103 		.loc 1 1290 0
 1815              		mov	r1, r8
 1816 0df0 B281D3E1 		mov	r0, r7
 1817              		bl	__udivsi3
 1818              		mov	r0, r0, asl #16
 1819 0df4 0170A011 		mov	r2, r0, lsr #16
 1820              	.LVL173:
 1821              		.loc 1 1291 0
 1822 0df8 0600001A 		mul	r3, r8, r2
 1823              		cmp	r3, r7
 1824 0dfc 490000EA 		.loc 1 1292 0
 1825              		addcc	r3, r2, #1
 1826              		movcc	r3, r3, asl #16
 1827              		movcc	r2, r3, lsr #16
 1828              		.loc 1 1293 0
 1829 0e00 000096E5 		ldr	r0, [r6, #0]
 1830 0e04 05FDFFEB 		mov	r1, r4
 1831              		bl	fat16_append_clusters
 1832              	.LVL174:
 1833 0e08 000050E3 		.loc 1 1294 0
 1834 0e0c 4F00000A 		cmp	r0, #0
 1835              		beq	.L235
 1836 0e10 077068E0 		.loc 1 1297 0
 1837 0e14 0040A0E1 		cmp	r5, #0
 1838              		.loc 1 1300 0
 1839              		strneh	r0, [r6, #38]	@ movhi
 1840              		movne	r4, r0
 1841              	.LVL175:
 1842 0e18 080057E1 	.L244:
 1843              	.LBE51:
 1844              		.loc 1 1306 0
 1845 0e1c 0410A0E1 		cmp	r9, #0
 1846              		.loc 1 1307 0
 1847              		movne	r3, #0	@ movhi
 1848 0e20 F6FFFF8A 		strneh	r3, [r6, #38]	@ movhi
 1849              		.loc 1 1305 0
 1850              		str	sl, [r6, #40]
 1851 0e24 015074E2 		.loc 1 1308 0
 1852 0e28 0050A033 		ldr	r0, [r6, #0]
 1853 0e2c 000055E3 		add	r1, r6, #4
 1854 0e30 1100000A 		bl	fat16_write_dir_entry
 1855              		cmp	r0, #0
 1856              		beq	.L235
 1857              		.loc 1 1311 0
 1858              		cmp	r9, #0
 1859 0e34 0810A0E1 		.loc 1 1314 0
 1860 0e38 0700A0E1 		movne	r1, r4
 1861 0e3c FEFFFFEB 		ldrne	r0, [r6, #0]
 1862 0e40 0008A0E1 		.loc 1 1311 0
 1863 0e44 2028A0E1 		bne	.L263
 1864              	.LVL176:
 1865              		.loc 1 1316 0
 1866 0e48 980203E0 		cmp	r7, r8
 1867 0e4c 070053E1 		bhi	.L237
 1868              		mov	r3, r4, asl #16
 1869 0e50 01308232 		ldr	r5, [r6, #0]
 1870 0e54 0338A031 	.LVL177:
 1871 0e58 2328A031 		mov	r4, r3, lsr #16
 1872              	.LVL178:
 1873 0e5c 000096E5 	.LBB52:
 1874 0e60 0410A0E1 		.loc 1 887 0
 1875 0e64 4DFDFFEB 		cmp	r5, #0
 1876              		cmpne	r4, #1
 1877              		bls	.L237
 1878 0e68 000050E3 		.loc 1 891 0
 1879 0e6c 3500000A 		mov	r1, r4
 1880              	.LVL179:
 1881 0e70 000055E3 		mov	r0, r5
 1882              		bl	fat16_get_next_cluster
 1883 0e74 B602C611 	.LBB53:
 1884 0e78 0040A011 		.loc 1 895 0
 1885              		mvn	r3, #0
 1886              		.loc 1 896 0
 1887              		strb	r3, [sp, #3]
 1888              		.loc 1 895 0
 1889 0e7c 000059E3 		strb	r3, [sp, #2]
 1890              	.LBE53:
 1891 0e80 0030A013 		.loc 1 891 0
 1892 0e84 B632C611 		mov	r7, r0
 1893              	.LVL180:
 1894 0e88 28A086E5 		.loc 1 897 0
 1895              		ldr	r0, [r5, #8]
 1896 0e8c 000096E5 		ldr	r3, [r5, #0]
 1897 0e90 041086E2 		add	r0, r0, r4, asl #1
 1898 0e94 27FFFFEB 		add	r1, sp, #2
 1899 0e98 000050E3 		mov	r2, #2
 1900 0e9c 2900000A 		ldr	ip, [r3, #8]
 1901              		mov	lr, pc
 1902 0ea0 000059E3 		bx	ip
 1903              	.LBB54:
 1904 0ea4 0410A011 		cmp	r0, #0
 1905 0ea8 00009615 		beq	.L237
 1906              		.loc 1 901 0
 1907 0eac 1C00001A 		cmp	r7, #0
 1908              		beq	.L237
 1909              	.LBE54:
 1910 0eb0 080057E1 		.loc 1 902 0
 1911 0eb4 1B00008A 		mov	r0, r5
 1912 0eb8 0438A0E1 		mov	r1, r7
 1913 0ebc 005096E5 	.LVL181:
 1914              	.L263:
 1915 0ec0 2348A0E1 		bl	fat16_free_clusters
 1916              	.LVL182:
 1917              	.L237:
 1918              	.LBE52:
 1919 0ec4 000055E3 		.loc 1 1326 0
 1920 0ec8 01005413 		ldr	r3, [r6, #48]
 1921 0ecc 1500009A 		cmp	sl, r3
 1922              		.loc 1 1329 0
 1923 0ed0 0410A0E1 		movcc	r3, #0	@ movhi
 1924              		.loc 1 1326 0
 1925 0ed4 0500A0E1 		movcs	r0, #1
 1926 0ed8 D0FCFFEB 		.loc 1 1329 0
 1927              		movcc	r0, #1
 1928              		.loc 1 1328 0
 1929 0edc 0030E0E3 		strcc	sl, [r6, #48]
 1930              		.loc 1 1329 0
 1931 0ee0 0330CDE5 		strcch	r3, [r6, #52]	@ movhi
 1932              		b	.L261
 1933 0ee4 0230CDE5 	.LVL183:
 1934              	.L235:
 1935              		mov	r0, #0
 1936 0ee8 0070A0E1 		b	.L261
 1937              	.LVL184:
 1938              	.L241:
 1939 0eec 080095E5 		.loc 1 1285 0
 1940 0ef0 003095E5 		rsbs	r5, r4, #1
 1941 0ef4 840080E0 		movcc	r5, #0
 1942 0ef8 02108DE2 		b	.L245
 1943 0efc 0220A0E3 	.LVL185:
 1944 0f00 08C093E5 	.L261:
 1945 0f04 0FE0A0E1 		.loc 1 1336 0
 1946 0f08 1CFF2FE1 		add	sp, sp, #4
 1947              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1948 0f0c 000050E3 		bx	lr
 1949 0f10 0400000A 	.LFE20:
 1951 0f14 000057E3 		.align	2
 1952 0f18 0200000A 		.global	fat16_seek_file
 1954              	fat16_seek_file:
 1955 0f1c 0500A0E1 	.LFB19:
 1956 0f20 0710A0E1 		.loc 1 1204 0
 1957              		@ Function supports interworking.
 1958              		@ args = 0, pretend = 0, frame = 0
 1959 0f24 E7FCFFEB 		@ frame_needed = 0, uses_anonymous_args = 0
 1960              	.LVL186:
 1961              		.loc 1 1205 0
 1962              		cmp	r1, #0
 1963              		cmpne	r0, #0
 1964 0f28 303096E5 		.loc 1 1204 0
 1965 0f2c 03005AE1 		stmfd	sp!, {r4, r5, r6, lr}
 1966              	.LCFI20:
 1967 0f30 0030A033 		.loc 1 1204 0
 1968              		and	r2, r2, #255
 1969 0f34 0100A023 		.loc 1 1205 0
 1970              		mov	r5, r0
 1971 0f38 0100A033 		mov	r6, r1
 1972              		beq	.L265
 1973 0f3c 30A08635 	.LVL187:
 1974              		.loc 1 1209 0
 1975 0f40 B433C631 		cmp	r2, #1
 1976 0f44 040000EA 		.loc 1 1208 0
 1977              		ldr	r1, [r0, #48]
 1978              	.LVL188:
 1979 0f48 0000A0E3 		.loc 1 1209 0
 1980 0f4c 020000EA 		beq	.L268
 1981              	.LVL189:
 1982              		.loc 1 1212 0
 1983              		ldrcc	r4, [r6, #0]
 1984 0f50 015074E2 	.LVL190:
 1985 0f54 0050A033 		.loc 1 1209 0
 1986 0f58 B5FFFFEA 		bcc	.L270
 1987              		cmp	r2, #2
 1988              		bne	.L265
 1989              		b	.L269
 1990 0f5c 04D08DE2 	.LVL191:
 1991 0f60 F047BDE8 	.L268:
 1992 0f64 1EFF2FE1 		.loc 1 1215 0
 1993              		ldr	r3, [r6, #0]
 1994              		add	r4, r1, r3
 1995              	.LVL192:
 1996              		b	.L270
 1997              	.L269:
 1998              		.loc 1 1218 0
 1999              		ldr	r2, [r0, #40]
 2000              	.LVL193:
 2001              		ldr	r3, [r6, #0]
 2002              		add	r4, r2, r3
 2003              	.LVL194:
 2004              	.L270:
 2005              		.loc 1 1224 0
 2006 0f68 000051E3 		ldr	r3, [r5, #40]
 2007 0f6c 00005013 		cmp	r4, r3
 2008              		bls	.L271
 2009 0f70 70402DE9 	.LVL195:
 2010              		mov	r0, r5
 2011              		mov	r1, r4
 2012 0f74 FF2002E2 	.LVL196:
 2013              		bl	fat16_resize_file
 2014 0f78 0050A0E1 	.LVL197:
 2015 0f7c 0160A0E1 		cmp	r0, #0
 2016 0f80 1B00000A 		beq	.L265
 2017              	.LVL198:
 2018              	.L271:
 2019 0f84 010052E3 		.loc 1 1228 0
 2020              		mov	r3, #0	@ movhi
 2021 0f88 301090E5 		.loc 1 1230 0
 2022              		mov	r0, #1
 2023              		.loc 1 1227 0
 2024 0f8c 0400000A 		str	r4, [r5, #48]
 2025              		.loc 1 1228 0
 2026              		strh	r3, [r5, #52]	@ movhi
 2027 0f90 00409635 		.loc 1 1230 0
 2028              		str	r4, [r6, #0]
 2029              		b	.L273
 2030 0f94 0800003A 	.LVL199:
 2031 0f98 020052E3 	.L265:
 2032 0f9c 1400001A 		.loc 1 1231 0
 2033 0fa0 020000EA 		mov	r0, #0
 2034              	.L273:
 2035              		.loc 1 1232 0
 2036              		ldmfd	sp!, {r4, r5, r6, lr}
 2037 0fa4 003096E5 		bx	lr
 2038 0fa8 034081E0 	.LFE19:
 2040 0fac 020000EA 		.align	2
 2041              		.global	fat16_write_file
 2043 0fb0 282090E5 	fat16_write_file:
 2044              	.LFB18:
 2045 0fb4 003096E5 		.loc 1 1058 0
 2046 0fb8 034082E0 		@ Function supports interworking.
 2047              		@ args = 0, pretend = 0, frame = 4
 2048              		@ frame_needed = 0, uses_anonymous_args = 0
 2049              	.LVL200:
 2050 0fbc 283095E5 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2051 0fc0 030054E1 	.LCFI21:
 2052 0fc4 0400009A 		mov	r2, r2, asl #16
 2053              	.LVL201:
 2054 0fc8 0500A0E1 		sub	sp, sp, #4
 2055 0fcc 0410A0E1 	.LCFI22:
 2056              		.loc 1 1058 0
 2057 0fd0 FEFFFFEB 		mov	r2, r2, lsr #16
 2058              		.loc 1 1061 0
 2059 0fd4 000050E3 		cmp	r1, #0
 2060 0fd8 0500000A 		cmpne	r0, #0
 2061              		mov	r4, r0
 2062              		mov	fp, r1
 2063              		.loc 1 1058 0
 2064 0fdc 0030A0E3 		str	r2, [sp, #0]
 2065              	.LVL202:
 2066 0fe0 0100A0E3 		.loc 1 1061 0
 2067              		beq	.L276
 2068 0fe4 304085E5 	.LVL203:
 2069              		cmp	r2, #0
 2070 0fe8 B433C5E1 		beq	.L276
 2071              		.loc 1 1063 0
 2072 0fec 004086E5 		ldr	sl, [r0, #48]
 2073 0ff0 000000EA 		ldr	r3, [r0, #40]
 2074              		cmp	sl, r3
 2075              		bhi	.L276
 2076              	.LVL204:
 2077 0ff4 0000A0E3 		.loc 1 1067 0
 2078              		ldrh	r5, [r0, #52]
 2079              	.LVL205:
 2080 0ff8 7040BDE8 		.loc 1 1066 0
 2081 0ffc 1EFF2FE1 		ldr	r0, [r0, #0]
 2082              	.LVL206:
 2083              		.loc 1 1072 0
 2084              		cmp	r5, #0
 2085              		.loc 1 1066 0
 2086              		ldrh	r8, [r0, #18]
 2087              	.LVL207:
 2088              		.loc 1 1072 0
 2089              		bne	.L280
 2090              		.loc 1 1074 0
 2091              		ldrh	r5, [r4, #38]
 2092              		.loc 1 1076 0
 2093              		cmp	r5, #0
 2094 1000 F04F2DE9 		bne	.L282
 2095              		.loc 1 1078 0
 2096 1004 0228A0E1 		cmp	sl, #0
 2097              		mvnne	r0, #1
 2098 1008 04D04DE2 		bne	.L286
 2099              		b	.L284
 2100              	.LVL208:
 2101 100c 2228A0E1 	.L308:
 2102              	.LBB55:
 2103 1010 000051E3 	.LBB56:
 2104 1014 00005013 		.loc 1 1138 0
 2105 1018 0040A0E1 		strh	r0, [r4, #52]	@ movhi
 2106 101c 01B0A0E1 		b	.L294
 2107              	.LVL209:
 2108 1020 00208DE5 	.L284:
 2109              	.LBE56:
 2110              	.LBE55:
 2111 1024 7B00000A 		.loc 1 1081 0
 2112              		mov	r1, r5
 2113 1028 000052E3 		mov	r2, #1
 2114 102c 7900000A 		bl	fat16_append_clusters
 2115              		.loc 1 1082 0
 2116 1030 30A090E5 		cmp	r0, #0
 2117 1034 283090E5 		.loc 1 1081 0
 2118 1038 03005AE1 		mov	r5, r0
 2119 103c 7500008A 		strh	r0, [r4, #38]	@ movhi
 2120              		.loc 1 1082 0
 2121              		beq	.L276
 2122 1040 B453D0E1 	.LVL210:
 2123              	.L282:
 2124              		.loc 1 1091 0
 2125 1044 000090E5 		ldr	r6, [r4, #48]
 2126              	.LVL211:
 2127              		cmp	r6, #0
 2128 1048 000055E3 		rsbne	r9, r8, #0
 2129              		rsbne	r7, r8, r6
 2130 104c B281D0E1 		bne	.L288
 2131              		b	.L280
 2132              	.LVL212:
 2133 1050 2400001A 	.L289:
 2134              	.LBB57:
 2135 1054 B652D4E1 		.loc 1 1098 0
 2136              		ldr	r0, [r4, #0]
 2137 1058 000055E3 	.LVL213:
 2138 105c 0C00001A 		bl	fat16_get_next_cluster
 2139              	.LVL214:
 2140 1060 00005AE3 		.loc 1 1099 0
 2141 1064 0100E013 		cmp	r0, #0
 2142 1068 6B00001A 		cmpeq	r7, #0
 2143 106c 010000EA 	.LBE57:
 2144              		.loc 1 1091 0
 2145              		add	r6, r6, r9
 2146              	.LBB58:
 2147              		.loc 1 1101 0
 2148              		add	r7, r7, r9
 2149 1070 B403C4E1 		mov	r1, r5
 2150 1074 520000EA 		mov	r2, #1
 2151              		.loc 1 1099 0
 2152              		.loc 1 1101 0
 2153              		ldreq	r0, [r4, #0]
 2154              	.LVL215:
 2155              		bleq	fat16_append_clusters
 2156 1078 0510A0E1 	.LVL216:
 2157 107c 0120A0E3 	.L290:
 2158 1080 C6FCFFEB 		.loc 1 1102 0
 2159              		subs	r5, r0, #0
 2160 1084 000050E3 		beq	.L307
 2161              	.LVL217:
 2162 1088 0050A0E1 	.L288:
 2163 108c B602C4E1 		.loc 1 1095 0
 2164              		cmp	r6, r8
 2165 1090 6000000A 		.loc 1 1098 0
 2166              		mov	r1, r5
 2167              		.loc 1 1095 0
 2168              		bcs	.L289
 2169 1094 306094E5 	.LVL218:
 2170              	.L280:
 2171 1098 000056E3 	.LBE58:
 2172 109c 00906812 		.loc 1 1069 0
 2173 10a0 06706810 		mov	r0, sl
 2174 10a4 0C00001A 	.LVL219:
 2175 10a8 0E0000EA 		mov	r1, r8
 2176              		bl	__umodsi3
 2177              		ldr	r7, [sp, #0]
 2178              	.LVL220:
 2179              		mov	r0, r0, asl #16
 2180 10ac 000094E5 		mov	sl, r0, lsr #16
 2181              	.LVL221:
 2182 10b0 5AFCFFEB 	.LVL222:
 2183              	.L293:
 2184              	.LBB59:
 2185 10b4 000050E3 		.loc 1 1115 0
 2186 10b8 00005703 		ldr	ip, [r4, #0]
 2187              		.loc 1 1116 0
 2188              		rsb	r3, sl, r8
 2189 10bc 096086E0 		.loc 1 1121 0
 2190              		ldr	r2, [ip, #24]
 2191              		.loc 1 1116 0
 2192 10c0 097087E0 		mov	r3, r3, asl #16
 2193 10c4 0510A0E1 		mov	r3, r3, lsr #16
 2194 10c8 0120A0E3 	.LVL223:
 2195              		cmp	r7, r3
 2196              		movcc	r6, r7
 2197 10cc 00009405 		movcs	r6, r3
 2198              	.LVL224:
 2199 10d0 B2FCFF0B 		.loc 1 1121 0
 2200              		add	r2, sl, r2
 2201              		sub	r3, r5, #2
 2202              	.LVL225:
 2203 10d4 005050E2 		mla	r0, r8, r3, r2
 2204 10d8 4C00000A 	.LVL226:
 2205              		mov	r1, fp
 2206              		mov	r2, r6
 2207              		ldr	r3, [ip, #0]
 2208 10dc 080056E1 		ldr	ip, [r3, #8]
 2209              		mov	lr, pc
 2210 10e0 0510A0E1 		bx	ip
 2211              		.loc 1 1126 0
 2212 10e4 F0FFFF2A 		rsb	r3, r6, r7
 2213              		.loc 1 1121 0
 2214              		cmp	r0, #0
 2215              	.LBB60:
 2216              		.loc 1 1132 0
 2217 10e8 0A00A0E1 		mov	r1, r5
 2218              	.LBE60:
 2219 10ec 0810A0E1 		.loc 1 1125 0
 2220 10f0 FEFFFFEB 		add	fp, fp, r6
 2221 10f4 00709DE5 		.loc 1 1129 0
 2222              		add	r2, sl, r6
 2223 10f8 0008A0E1 		.loc 1 1126 0
 2224 10fc 20A8A0E1 		mov	r0, r3, asl #16
 2225              		.loc 1 1121 0
 2226              		beq	.L294
 2227              		.loc 1 1127 0
 2228              		ldr	r3, [r4, #48]
 2229              		.loc 1 1129 0
 2230 1100 00C094E5 		cmp	r2, r8
 2231              		.loc 1 1127 0
 2232 1104 08306AE0 		add	r3, r3, r6
 2233              		str	r3, [r4, #48]
 2234 1108 18209CE5 		.loc 1 1126 0
 2235              		mov	r7, r0, lsr #16
 2236 110c 0338A0E1 		.loc 1 1129 0
 2237 1110 2338A0E1 		blt	.L296
 2238              	.LBB61:
 2239 1114 030057E1 		.loc 1 1132 0
 2240 1118 0760A031 		ldr	r0, [r4, #0]
 2241 111c 0360A021 		bl	fat16_get_next_cluster
 2242              		.loc 1 1139 0
 2243              		mov	sl, #0
 2244 1120 02208AE0 	.LVL227:
 2245 1124 023045E2 		.loc 1 1133 0
 2246              		cmp	r0, sl
 2247 1128 982320E0 		movne	r3, #0
 2248              		moveq	r3, #1
 2249 112c 0B10A0E1 		cmp	r7, sl
 2250 1130 0620A0E1 		moveq	r3, #0
 2251 1134 00309CE5 		cmp	r3, sl
 2252 1138 08C093E5 		.loc 1 1135 0
 2253 113c 0FE0A0E1 		mov	r1, r5
 2254 1140 1CFF2FE1 		mov	r2, #1
 2255              		.loc 1 1133 0
 2256 1144 073066E0 		.loc 1 1135 0
 2257              		ldrne	r0, [r4, #0]
 2258 1148 000050E3 	.LVL228:
 2259              		blne	fat16_append_clusters
 2260              	.LVL229:
 2261 114c 0510A0E1 	.L298:
 2262              		.loc 1 1136 0
 2263              		cmp	r0, #0
 2264 1150 06B08BE0 		.loc 1 1139 0
 2265              		mov	r5, r0
 2266 1154 06208AE0 		.loc 1 1136 0
 2267              		beq	.L308
 2268 1158 0308A0E1 	.LVL230:
 2269              	.L296:
 2270 115c 1800000A 	.LBE61:
 2271              	.LBE59:
 2272 1160 303094E5 		.loc 1 1149 0
 2273              		cmp	r7, #0
 2274 1164 080052E1 	.LBB62:
 2275              		.loc 1 1146 0
 2276 1168 063083E0 		strh	r5, [r4, #52]	@ movhi
 2277 116c 303084E5 	.LBE62:
 2278              		.loc 1 1149 0
 2279 1170 2078A0E1 		bne	.L293
 2280              	.L294:
 2281 1174 0F0000BA 		.loc 1 1152 0
 2282              		ldr	r3, [r4, #48]
 2283              		ldr	r5, [r4, #40]
 2284 1178 000094E5 	.LVL231:
 2285 117c 27FCFFEB 		cmp	r3, r5
 2286              		bls	.L303
 2287 1180 00A0A0E3 	.LBB63:
 2288              		.loc 1 1157 0
 2289              		str	r3, [r4, #40]
 2290 1184 0A0050E1 		.loc 1 1159 0
 2291 1188 0030A013 		ldr	r0, [r4, #0]
 2292 118c 0130A003 	.LVL232:
 2293 1190 0A0057E1 		add	r1, r4, #4
 2294 1194 0030A003 		bl	fat16_write_dir_entry
 2295 1198 0A0053E1 		cmp	r0, #0
 2296              		.loc 1 1165 0
 2297 119c 0510A0E1 		ldreq	r3, [r4, #48]
 2298 11a0 0120A0E3 		rsbeq	r3, r5, r3
 2299              		moveq	r3, r3, asl #16
 2300              		.loc 1 1166 0
 2301 11a4 00009415 		streq	r5, [r4, #48]
 2302              		.loc 1 1165 0
 2303 11a8 7CFCFF1B 		moveq	r7, r3, lsr #16
 2304              	.LVL233:
 2305              	.L303:
 2306              	.LBE63:
 2307 11ac 000050E3 		.loc 1 1170 0
 2308              		ldr	r2, [sp, #0]
 2309 11b0 0050A0E1 		rsb	r3, r7, r2
 2310              		mov	r3, r3, asl #16
 2311 11b4 ADFFFF0A 		mov	r0, r3, asr #16
 2312              	.LVL234:
 2313              		b	.L286
 2314              	.LVL235:
 2315              	.L307:
 2316              	.LBB64:
 2317 11b8 000057E3 		.loc 1 1102 0
 2318              		mvn	r0, #2
 2319              	.LVL236:
 2320 11bc B453C4E1 		b	.L286
 2321              	.LVL237:
 2322              	.L276:
 2323 11c0 CEFFFF1A 	.LBE64:
 2324              		.loc 1 1170 0
 2325              		mvn	r0, #0
 2326 11c4 303094E5 	.LVL238:
 2327 11c8 285094E5 	.L286:
 2328              		.loc 1 1175 0
 2329 11cc 050053E1 		add	sp, sp, #4
 2330 11d0 0900009A 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2331              		bx	lr
 2332              	.LFE18:
 2334              		.align	2
 2335 11d8 000094E5 		.global	fat16_close_dir
 2337 11dc 041084E2 	fat16_close_dir:
 2338 11e0 54FEFFEB 	.LFB22:
 2339 11e4 000050E3 		.loc 1 1375 0
 2340              		@ Function supports interworking.
 2341 11e8 30309405 		@ args = 0, pretend = 0, frame = 0
 2342 11ec 03306500 		@ frame_needed = 0, uses_anonymous_args = 0
 2343 11f0 0338A001 	.LVL239:
 2344              		.loc 1 1376 0
 2345 11f4 30508405 		cmp	r0, #0
 2346              		.loc 1 1375 0
 2347 11f8 2378A001 		str	lr, [sp, #-4]!
 2348              	.LCFI23:
 2349              		.loc 1 1376 0
 2350              		.loc 1 1377 0
 2351              		blne	free
 2352 11fc 00209DE5 	.LVL240:
 2353 1200 023067E0 	.LVL241:
 2354 1204 0338A0E1 	.L312:
 2355 1208 4308A0E1 		.loc 1 1378 0
 2356              		ldr	lr, [sp], #4
 2357 120c 020000EA 		bx	lr
 2358              	.LFE22:
 2360              		.align	2
 2361              		.global	fat16_close_file
 2363              	fat16_close_file:
 2364 1214 000000EA 	.LFB16:
 2365              		.loc 1 944 0
 2366              		@ Function supports interworking.
 2367              		@ args = 0, pretend = 0, frame = 0
 2368              		@ frame_needed = 0, uses_anonymous_args = 0
 2369 1218 0000E0E3 	.LVL242:
 2370              		.loc 1 945 0
 2371              		cmp	r0, #0
 2372              		.loc 1 944 0
 2373 121c 04D08DE2 		str	lr, [sp, #-4]!
 2374 1220 F04FBDE8 	.LCFI24:
 2375 1224 1EFF2FE1 		.loc 1 945 0
 2376              		.loc 1 946 0
 2377              		blne	free
 2378              	.LVL243:
 2379              	.LVL244:
 2380              	.L316:
 2381              		.loc 1 947 0
 2382              		ldr	lr, [sp], #4
 2383              		bx	lr
 2384              	.LFE16:
 2386              		.align	2
 2387              		.global	fat16_close
 2389 1228 000050E3 	fat16_close:
 2390              	.LFB3:
 2391 122c 04E02DE5 		.loc 1 243 0
 2392              		@ Function supports interworking.
 2393              		@ args = 0, pretend = 0, frame = 0
 2394              		@ frame_needed = 0, uses_anonymous_args = 0
 2395 1230 FEFFFF1B 	.LVL245:
 2396              		.loc 1 244 0
 2397              		cmp	r0, #0
 2398              		.loc 1 243 0
 2399              		str	lr, [sp, #-4]!
 2400 1234 04E09DE4 	.LCFI25:
 2401 1238 1EFF2FE1 		.loc 1 244 0
 2402              		.loc 1 247 0
 2403              		blne	free
 2404              	.LVL246:
 2405              	.LVL247:
 2406              	.L320:
 2407              		.loc 1 248 0
 2408              		ldr	lr, [sp], #4
 2409              		bx	lr
 2410              	.LFE3:
 2412              		.align	2
 2413              		.global	fat16_open_dir
 2415 123c 000050E3 	fat16_open_dir:
 2416              	.LFB21:
 2417 1240 04E02DE5 		.loc 1 1348 0
 2418              		@ Function supports interworking.
 2419              		@ args = 0, pretend = 0, frame = 0
 2420              		@ frame_needed = 0, uses_anonymous_args = 0
 2421 1244 FEFFFF1B 	.LVL248:
 2422              		.loc 1 1349 0
 2423              		cmp	r1, #0
 2424              		cmpne	r0, #0
 2425              		.loc 1 1348 0
 2426 1248 04E09DE4 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2427 124c 1EFF2FE1 	.LCFI26:
 2428              		.loc 1 1349 0
 2429              		mov	r7, r0
 2430              		mov	r5, r1
 2431              		movne	r8, #0
 2432              		moveq	r8, #1
 2433              		beq	.L322
 2434              	.LVL249:
 2435              		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2436              		tst	r3, #16
 2437              		.loc 1 1352 0
 2438              		mov	r0, #52
 2439              		.loc 1 1349 0
 2440              		beq	.L322
 2441 1250 000050E3 	.LVL250:
 2442              		.loc 1 1352 0
 2443 1254 04E02DE5 		bl	malloc
 2444              	.LVL251:
 2445              		.loc 1 1353 0
 2446              		cmp	r0, #0
 2447 1258 FEFFFF1B 		.loc 1 1352 0
 2448              		mov	r6, r0
 2449              	.LVL252:
 2450              		.loc 1 1356 0
 2451              		add	r4, r0, #4
 2452 125c 04E09DE4 		.loc 1 1353 0
 2453 1260 1EFF2FE1 		beq	.L322
 2454              	.LVL253:
 2455              		.loc 1 1356 0
 2456              		mov	ip, r5
 2457              		ldmia	ip!, {r0, r1, r2, r3}
 2458              	.LVL254:
 2459              		mov	lr, r4
 2460              		stmia	lr!, {r0, r1, r2, r3}
 2461              		ldmia	ip!, {r0, r1, r2, r3}
 2462              		stmia	lr!, {r0, r1, r2, r3}
 2463              		ldmia	ip, {r0, r1, r2}
 2464              		.loc 1 1357 0
 2465              		str	r7, [r6, #0]
 2466              		.loc 1 1356 0
 2467 1264 000051E3 		stmia	lr, {r0, r1, r2}
 2468 1268 00005013 		.loc 1 1358 0
 2469              		strh	r8, [r6, #48]	@ movhi
 2470 126c F0412DE9 		b	.L326
 2471              	.LVL255:
 2472              	.L322:
 2473 1270 0070A0E1 		.loc 1 1360 0
 2474 1274 0150A0E1 		mov	r6, #0
 2475 1278 0080A013 	.LVL256:
 2476 127c 0180A003 	.L326:
 2477 1280 1300000A 		.loc 1 1361 0
 2478              		mov	r0, r6
 2479 1284 2030D1E5 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2480 1288 100013E3 		bx	lr
 2481              	.LFE21:
 2483              		.align	2
 2484 1290 0F00000A 		.global	fat16_open_file
 2486              	fat16_open_file:
 2487 1294 FEFFFFEB 	.LFB15:
 2488              		.loc 1 920 0
 2489              		@ Function supports interworking.
 2490 1298 000050E3 		@ args = 0, pretend = 0, frame = 0
 2491              		@ frame_needed = 0, uses_anonymous_args = 0
 2492 129c 0060A0E1 	.LVL257:
 2493              		.loc 1 921 0
 2494              		cmp	r1, #0
 2495 12a0 044080E2 		cmpne	r0, #0
 2496              		.loc 1 920 0
 2497 12a4 0A00000A 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2498              	.LCFI27:
 2499              		.loc 1 921 0
 2500 12a8 05C0A0E1 		mov	r5, r1
 2501 12ac 0F00BCE8 		mov	r7, r0
 2502              		beq	.L329
 2503 12b0 04E0A0E1 	.LVL258:
 2504 12b4 0F00AEE8 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2505 12b8 0F00BCE8 		ands	r8, r3, #16
 2506 12bc 0F00AEE8 		.loc 1 924 0
 2507 12c0 07009CE8 		mov	r0, #56
 2508              		.loc 1 921 0
 2509 12c4 007086E5 		bne	.L329
 2510              	.LVL259:
 2511 12c8 07008EE8 		.loc 1 924 0
 2512              		bl	malloc
 2513 12cc B083C6E1 	.LVL260:
 2514 12d0 000000EA 		.loc 1 925 0
 2515              		cmp	r0, #0
 2516              		.loc 1 924 0
 2517              		mov	r6, r0
 2518 12d4 0060A0E3 	.LVL261:
 2519              		.loc 1 928 0
 2520              		add	r4, r0, #4
 2521              		.loc 1 925 0
 2522 12d8 0600A0E1 		beq	.L329
 2523 12dc F041BDE8 	.LVL262:
 2524 12e0 1EFF2FE1 		.loc 1 928 0
 2525              		mov	ip, r5
 2526              		ldmia	ip!, {r0, r1, r2, r3}
 2527              	.LVL263:
 2528              		mov	lr, r4
 2529              		stmia	lr!, {r0, r1, r2, r3}
 2530              		ldmia	ip!, {r0, r1, r2, r3}
 2531              		stmia	lr!, {r0, r1, r2, r3}
 2532              		ldmia	ip, {r0, r1, r2}
 2533              		stmia	lr, {r0, r1, r2}
 2534              		.loc 1 931 0
 2535              		ldrh	r5, [r5, #34]
 2536              	.LVL264:
 2537              		.loc 1 929 0
 2538 12e4 000051E3 		str	r7, [r6, #0]
 2539 12e8 00005013 		.loc 1 930 0
 2540              		str	r8, [r6, #48]
 2541 12ec F0412DE9 		.loc 1 931 0
 2542              		strh	r5, [r6, #52]	@ movhi
 2543              		b	.L333
 2544 12f0 0150A0E1 	.LVL265:
 2545 12f4 0070A0E1 	.L329:
 2546 12f8 1500000A 		.loc 1 933 0
 2547              		mov	r6, #0
 2548 12fc 2030D1E5 	.LVL266:
 2549 1300 108013E2 	.L333:
 2550              		.loc 1 934 0
 2551 1304 3800A0E3 		mov	r0, r6
 2552              		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2553 1308 1100001A 		bx	lr
 2554              	.LFE15:
 2556 130c FEFFFFEB 		.align	2
 2557              		.global	open_file_in_dir
 2559 1310 000050E3 	open_file_in_dir:
 2560              	.LFB33:
 2561 1314 0060A0E1 		.loc 1 1936 0
 2562              		@ Function supports interworking.
 2563              		@ args = 0, pretend = 0, frame = 44
 2564 1318 044080E2 		@ frame_needed = 0, uses_anonymous_args = 0
 2565              	.LVL267:
 2566 131c 0C00000A 		stmfd	sp!, {r4, r5, lr}
 2567              	.LCFI28:
 2568              		sub	sp, sp, #44
 2569 1320 05C0A0E1 	.LCFI29:
 2570 1324 0F00BCE8 		.loc 1 1938 0
 2571              		mov	r3, sp
 2572 1328 04E0A0E1 		.loc 1 1936 0
 2573 132c 0F00AEE8 		mov	r4, r0
 2574 1330 0F00BCE8 		.loc 1 1938 0
 2575 1334 0F00AEE8 		bl	find_file_in_dir
 2576 1338 07009CE8 	.LVL268:
 2577 133c 07008EE8 		cmp	r0, #0
 2578              		mov	r3, r0
 2579 1340 B252D5E1 		mov	r5, sp
 2580              		.loc 1 1941 0
 2581              		mov	r0, r4
 2582 1344 007086E5 		mov	r1, sp
 2583              		.loc 1 1938 0
 2584 1348 308086E5 		beq	.L338
 2585              	.LVL269:
 2586 134c B453C6E1 		.loc 1 1941 0
 2587 1350 000000EA 		bl	fat16_open_file
 2588              	.LVL270:
 2589              		mov	r3, r0
 2590              	.LVL271:
 2591 1354 0060A0E3 	.L338:
 2592              		.loc 1 1942 0
 2593              		mov	r0, r3
 2594              		add	sp, sp, #44
 2595 1358 0600A0E1 		ldmfd	sp!, {r4, r5, lr}
 2596 135c F041BDE8 		bx	lr
 2597 1360 1EFF2FE1 	.LFE33:
 2599              		.align	2
 2600              		.global	fat16_get_dir_entry_of_path
 2602              	fat16_get_dir_entry_of_path:
 2603              	.LFB10:
 2604              		.loc 1 624 0
 2605              		@ Function supports interworking.
 2606              		@ args = 0, pretend = 0, frame = 0
 2607              		@ frame_needed = 0, uses_anonymous_args = 0
 2608              	.LVL272:
 2609              		.loc 1 625 0
 2610 1364 30402DE9 		cmp	r1, #0
 2611              		cmpne	r0, #0
 2612 1368 2CD04DE2 		.loc 1 624 0
 2613              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2614              	.LCFI30:
 2615 136c 0D30A0E1 		.loc 1 625 0
 2616              		mov	r9, r0
 2617 1370 0040A0E1 		mov	r4, r1
 2618              		.loc 1 624 0
 2619 1374 FEFFFFEB 		mov	r5, r2
 2620              		.loc 1 625 0
 2621 1378 000050E3 		beq	.L341
 2622 137c 0030A0E1 	.LVL273:
 2623 1380 0D50A0E1 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 2624              		cmp	r2, #0
 2625 1384 0400A0E1 		cmpne	r3, #0
 2626 1388 0D10A0E1 		movne	r1, #0
 2627              		moveq	r1, #1
 2628 138c 0100000A 		beq	.L341
 2629              	.LVL274:
 2630              		.loc 1 628 0
 2631 1390 FEFFFFEB 		cmp	r3, #47
 2632              		.loc 1 632 0
 2633 1394 0030A0E1 		mov	r0, r2
 2634              		mov	r2, #44
 2635              	.LVL275:
 2636              		.loc 1 629 0
 2637 1398 0300A0E1 		addeq	r4, r4, #1
 2638 139c 2CD08DE2 		.loc 1 632 0
 2639 13a0 3040BDE8 		bl	memset
 2640 13a4 1EFF2FE1 	.LVL276:
 2641              		.loc 1 633 0
 2642              		mov	r3, #16
 2643              		strb	r3, [r5, #32]
 2644              		.loc 1 635 0
 2645              		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 2646              		cmp	r3, #0
 2647              		beq	.L346
 2648              	.LVL277:
 2649              	.L364:
 2650              	.LBB65:
 2651              		.loc 1 640 0
 2652              		mov	r0, r9
 2653              		mov	r1, r5
 2654 13a8 000051E3 		bl	fat16_open_dir
 2655 13ac 00005013 		.loc 1 641 0
 2656              		subs	r7, r0, #0
 2657 13b0 F0472DE9 		beq	.L341
 2658              		.loc 1 645 0
 2659              		mov	r0, r4
 2660 13b4 0090A0E1 		mov	r1, #47
 2661 13b8 0140A0E1 		bl	strchr
 2662              		.loc 1 646 0
 2663 13bc 0250A0E1 		subs	r8, r0, #0
 2664              		bne	.L349
 2665 13c0 3C00000A 		.loc 1 647 0
 2666              		mov	r0, r4
 2667 13c4 0030D1E5 		bl	strlen
 2668 13c8 000052E3 		add	r8, r4, r0
 2669 13cc 00005313 	.L349:
 2670 13d0 0010A013 		.loc 1 648 0
 2671 13d4 0110A003 		rsb	r3, r4, r8
 2672 13d8 3600000A 		and	r6, r3, #255
 2673              		b	.L366
 2674              	.L352:
 2675 13dc 2F0053E3 		.loc 1 654 0
 2676              		bl	strlen
 2677 13e0 0200A0E1 		cmp	r0, r6
 2678 13e4 2C20A0E3 		mov	r1, r5
 2679              		mov	r2, r6
 2680              		mov	r0, r4
 2681 13e8 01408402 		bne	.L366
 2682              	.LVL278:
 2683 13ec FEFFFFEB 		bl	strncmp
 2684              	.LVL279:
 2685              		subs	sl, r0, #0
 2686 13f0 1030A0E3 		bne	.L366
 2687 13f4 2030C5E5 		.loc 1 658 0
 2688              		mov	r0, r7
 2689 13f8 0030D4E5 		bl	fat16_close_dir
 2690 13fc 000053E3 		.loc 1 661 0
 2691 1400 2E00000A 		ldrb	r3, [r4, r6]	@ zero_extendqisi2
 2692              		cmp	r3, #0
 2693              		beq	.L346
 2694              		.loc 1 665 0
 2695              		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 2696 1404 0900A0E1 		tst	r3, #16
 2697 1408 0510A0E1 		beq	.L341
 2698 140c FEFFFFEB 		.loc 1 668 0
 2699              		add	r4, r8, #1
 2700 1410 007050E2 		mov	r7, sl
 2701 1414 2700000A 		b	.L357
 2702              	.LVL280:
 2703 1418 0400A0E1 	.L366:
 2704 141c 2F10A0E3 		.loc 1 651 0
 2705 1420 FEFFFFEB 		mov	r1, r5
 2706              		mov	r0, r7
 2707 1424 008050E2 		bl	fat16_read_dir
 2708 1428 0200001A 		cmp	r0, #0
 2709              		.loc 1 654 0
 2710 142c 0400A0E1 		mov	r0, r5
 2711 1430 FEFFFFEB 		.loc 1 651 0
 2712 1434 008084E0 		bne	.L352
 2713              	.L357:
 2714              		.loc 1 676 0
 2715 1438 083064E0 		mov	r0, r7
 2716 143c FF6003E2 		bl	fat16_close_dir
 2717 1440 130000EA 		b	.L364
 2718              	.LVL281:
 2719              	.L341:
 2720 1444 FEFFFFEB 		.loc 1 677 0
 2721 1448 060050E1 		mov	r0, #0
 2722 144c 0510A0E1 		b	.L358
 2723 1450 0620A0E1 	.LVL282:
 2724 1454 0400A0E1 	.L346:
 2725 1458 0D00001A 		mov	r0, #1
 2726              	.LVL283:
 2727 145c FEFFFFEB 	.L358:
 2728              	.LBE65:
 2729 1460 00A050E2 		.loc 1 680 0
 2730 1464 0A00001A 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2731              		bx	lr
 2732 1468 0700A0E1 	.LFE10:
 2734              		.section	.rodata.str1.4,"aMS",%progbits,1
 2735 1470 0630D4E7 		.align	2
 2736 1474 000053E3 	.LC0:
 2737 1478 1000000A 		.ascii	"MALLOC FAILS\012\015\000"
 2738              		.align	2
 2739 147c 2030D5E5 	.LC1:
 2740 1480 100013E3 		.ascii	"Failed Reading Header\012\015\000"
 2741 1484 0B00000A 		.text
 2742              		.align	2
 2743 1488 014088E2 		.global	fat16_open
 2745 1490 050000EA 	fat16_open:
 2746              	.LFB2:
 2747              		.loc 1 203 0
 2748              		@ Function supports interworking.
 2749 1494 0510A0E1 		@ args = 0, pretend = 0, frame = 60
 2750 1498 0700A0E1 		@ frame_needed = 0, uses_anonymous_args = 0
 2751 149c FEFFFFEB 	.LVL284:
 2752 14a0 000050E3 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2753              	.LCFI31:
 2754 14a4 0500A0E1 		.loc 1 204 0
 2755              		subs	r8, r0, #0
 2756 14a8 E5FFFF1A 		.loc 1 203 0
 2757              		sub	sp, sp, #60
 2758              	.LCFI32:
 2759 14ac 0700A0E1 		.loc 1 204 0
 2760 14b0 FEFFFFEB 		beq	.L382
 2761 14b4 D2FFFFEA 	.LVL285:
 2762              		ldr	r3, [r8, #8]
 2763              		cmp	r3, #0
 2764              		beq	.L382
 2765 14b8 0000A0E3 		.loc 1 213 0
 2766 14bc 000000EA 		mov	r0, #28
 2767              		bl	malloc
 2768              		.loc 1 214 0
 2769 14c0 0100A0E3 		subs	fp, r0, #0
 2770              		bne	.L371
 2771              		.loc 1 216 0
 2772              		ldr	r0, .L383
 2773              		bl	rprintf
 2774 14c4 F047BDE8 		mov	sl, fp
 2775 14c8 1EFF2FE1 	.LVL286:
 2776              		b	.L373
 2777              	.LVL287:
 2778              	.L371:
 2779              		.loc 1 219 0
 2780              		mov	r1, #0
 2781 0000 4D414C4C 		mov	r2, #28
 2781      4F432046 
 2781      41494C53 
 2781      0A0D00
 2782 000f 00       		bl	memset
 2783              	.LBB68:
 2784 0010 4661696C 	.LBB69:
 2784      65642052 
 2784      65616469 
 2784      6E672048 
 2784      65616465 
 2785              		.loc 1 271 0
 2786              		ldr	r3, [r8, #16]
 2787              		mov	r3, r3, asl #9
 2788              		str	r3, [sp, #8]
 2789              	.LVL288:
 2790              	.LVL289:
 2791              	.LBE69:
 2792              	.LBE68:
 2793              		.loc 1 221 0
 2794              		str	r8, [fp, #0]
 2795              	.LBB70:
 2796 14cc F04F2DE9 		.loc 1 273 0
 2797              		add	r0, r3, #11
 2798              		add	r1, sp, #35
 2799 14d0 008050E2 		mov	r2, #25
 2800              		ldr	ip, [r8, #0]
 2801 14d4 3CD04DE2 		mov	lr, pc
 2802              		bx	ip
 2803              	.LBB71:
 2804 14d8 7100000A 		cmp	r0, #0
 2805              	.LVL290:
 2806 14dc 083098E5 	.LBE71:
 2807 14e0 000053E3 	.LBE70:
 2808 14e4 6E00000A 		.loc 1 213 0
 2809              		mov	sl, fp
 2810 14e8 1C00A0E3 	.LVL291:
 2811 14ec FEFFFFEB 	.LBB72:
 2812              	.LBB73:
 2813 14f0 00B050E2 		.loc 1 273 0
 2814 14f4 0300001A 		beq	.L374
 2815              		.loc 1 287 0
 2816 14f8 B8019FE5 		ldrb	r2, [sp, #46]	@ zero_extendqisi2
 2817 14fc FEFFFFEB 		ldrb	r3, [sp, #47]	@ zero_extendqisi2
 2818 1500 0BA0A0E1 		.loc 1 293 0
 2819              		orrs	r3, r2, r3, asl #8
 2820 1504 670000EA 		.loc 1 277 0
 2821              		ldrb	r0, [sp, #35]	@ zero_extendqisi2
 2822              		ldrb	r2, [sp, #36]	@ zero_extendqisi2
 2823              		.loc 1 293 0
 2824 1508 0010A0E3 		str	r3, [sp, #16]
 2825 150c 1C20A0E3 		.loc 1 280 0
 2826 1510 FEFFFFEB 		ldrb	r6, [sp, #38]	@ zero_extendqisi2
 2827              		.loc 1 278 0
 2828              		ldrb	r3, [sp, #37]	@ zero_extendqisi2
 2829              		.loc 1 277 0
 2830 1514 103098E5 		str	r0, [sp, #28]
 2831 1518 8334A0E1 		str	r2, [sp, #24]
 2832 151c 08308DE5 		.loc 1 278 0
 2833              		str	r3, [sp, #4]
 2834              	.LVL292:
 2835              		.loc 1 280 0
 2836              		str	r6, [sp, #20]
 2837              		ldrb	r1, [sp, #39]	@ zero_extendqisi2
 2838 1520 00808BE5 		.loc 1 281 0
 2839              		ldrb	r9, [sp, #40]	@ zero_extendqisi2
 2840              	.LVL293:
 2841 1524 0B0083E2 		.loc 1 283 0
 2842 1528 23108DE2 		ldrb	r7, [sp, #41]	@ zero_extendqisi2
 2843 152c 1920A0E3 		ldrb	r5, [sp, #42]	@ zero_extendqisi2
 2844 1530 00C098E5 		.loc 1 285 0
 2845 1534 0FE0A0E1 		ldrb	r4, [sp, #43]	@ zero_extendqisi2
 2846 1538 1CFF2FE1 		ldrb	lr, [sp, #44]	@ zero_extendqisi2
 2847              		.loc 1 291 0
 2848 153c 000050E3 		ldrb	ip, [sp, #56]	@ zero_extendqisi2
 2849              		ldrb	r2, [sp, #57]	@ zero_extendqisi2
 2850              		ldrb	r3, [sp, #58]	@ zero_extendqisi2
 2851              		ldrb	r0, [sp, #59]	@ zero_extendqisi2
 2852              		.loc 1 293 0
 2853 1540 0BA0A0E1 		beq	.L374
 2854              		.loc 1 291 0
 2855              		mov	r3, r3, asl #16
 2856              		orr	r2, ip, r2, asl #8
 2857              		orr	r3, r3, r0, asl #24
 2858 1544 5200000A 		.loc 1 297 0
 2859              		orrs	r6, r2, r3
 2860 1548 2E20DDE5 	.LVL294:
 2861 154c 2F30DDE5 		bne	.L377
 2862              		.loc 1 299 0
 2863 1550 033492E1 		orrs	r2, r4, lr, asl #8
 2864              		beq	.L374
 2865 1554 2300DDE5 		.loc 1 303 0
 2866 1558 2420DDE5 		mov	r6, r2
 2867              	.L377:
 2868 155c 10308DE5 		.loc 1 310 0
 2869              		ldr	r0, [sp, #16]
 2870 1560 2660DDE5 		mul	r0, r9, r0
 2871              		.loc 1 277 0
 2872 1564 2530DDE5 		ldr	r2, [sp, #28]
 2873              		.loc 1 310 0
 2874 1568 1C008DE5 		str	r0, [sp, #12]
 2875 156c 18208DE5 		.loc 1 277 0
 2876              		ldr	r0, [sp, #24]
 2877 1570 04308DE5 		.loc 1 283 0
 2878              		orr	r3, r7, r5, asl #8
 2879              	.LVL295:
 2880 1574 14608DE5 		.loc 1 277 0
 2881 1578 2710DDE5 		orr	r5, r2, r0, asl #8
 2882              	.LVL296:
 2883 157c 2890DDE5 		.loc 1 310 0
 2884              		ldr	r2, [sp, #20]
 2885              		.loc 1 311 0
 2886 1580 2970DDE5 		mov	r3, r3, asl #5
 2887 1584 2A50DDE5 	.LVL297:
 2888              		.loc 1 310 0
 2889 1588 2B40DDE5 		orr	r9, r2, r1, asl #8
 2890 158c 2CE0DDE5 	.LVL298:
 2891              		.loc 1 311 0
 2892 1590 38C0DDE5 		str	r3, [sp, #0]
 2893 1594 3920DDE5 		add	r0, r3, r5
 2894 1598 3A30DDE5 		ldr	r3, [sp, #12]
 2895 159c 3B00DDE5 		mov	r1, r5
 2896              		sub	r0, r0, #1
 2897 15a0 3B00000A 		rsb	r4, r9, r6
 2898              		rsb	r4, r3, r4
 2899 15a4 0338A0E1 		bl	__divsi3
 2900 15a8 02248CE1 		ldr	r1, [sp, #4]
 2901 15ac 003C83E1 		rsb	r0, r0, r4
 2902              		bl	__udivsi3
 2903 15b0 036092E1 		.loc 1 312 0
 2904              		sub	r3, r0, #4080
 2905 15b4 0200001A 		sub	r3, r3, #5
 2906              		cmp	r3, #61440
 2907 15b8 0E2494E1 		.loc 1 311 0
 2908 15bc 3400000A 		mov	r7, r0
 2909              		.loc 1 312 0
 2910 15c0 0260A0E1 		bcs	.L374
 2911              		.loc 1 319 0
 2912              		add	r4, sl, #4
 2913 15c4 10009DE5 	.LVL299:
 2914 15c8 990000E0 		.loc 1 316 0
 2915              		mov	r3, #6
 2916 15cc 1C209DE5 		strb	r3, [r8, #12]
 2917              		.loc 1 320 0
 2918 15d0 0C008DE5 		mov	r1, #0
 2919              		mov	r2, #24
 2920 15d4 18009DE5 		mov	r0, r4
 2921              		bl	memset
 2922 15d8 053487E1 		.loc 1 324 0
 2923              		ldr	ip, [sp, #8]
 2924              		mla	ip, r5, r9, ip
 2925 15dc 005482E1 		.loc 1 333 0
 2926              		ldr	lr, [sp, #12]
 2927              		.loc 1 331 0
 2928 15e0 14209DE5 		ldr	r0, [sp, #4]
 2929              		.loc 1 333 0
 2930 15e4 8332A0E1 		mla	lr, r5, lr, ip
 2931              		.loc 1 322 0
 2932              		mul	r1, r5, r6
 2933 15e8 019482E1 		.loc 1 331 0
 2934              		mul	r0, r5, r0
 2935              		.loc 1 338 0
 2936 15ec 00308DE5 		ldr	r6, [sp, #0]
 2937 15f0 050083E0 	.LVL300:
 2938 15f4 0C309DE5 		.loc 1 328 0
 2939 15f8 0510A0E1 		mov	r3, r7, asl #1
 2940 15fc 010040E2 		.loc 1 338 0
 2941 1600 064069E0 		add	r2, lr, r6
 2942 1604 044063E0 		.loc 1 328 0
 2943 1608 FEFFFFEB 		add	r3, r3, #4
 2944 160c 04109DE5 		.loc 1 338 0
 2945 1610 040060E0 		str	r2, [r4, #20]
 2946 1614 FEFFFFEB 		.loc 1 322 0
 2947              		str	r1, [sl, #4]
 2948 1618 FF3E40E2 		.loc 1 328 0
 2949 161c 053043E2 		str	r3, [r4, #8]
 2950 1620 0F0A53E3 		.loc 1 331 0
 2951              		strh	r0, [r4, #14]	@ movhi
 2952 1624 0070A0E1 		.loc 1 324 0
 2953              		str	ip, [r4, #4]
 2954 1628 1900002A 		.loc 1 330 0
 2955              		strh	r5, [r4, #12]	@ movhi
 2956 162c 04408AE2 		.loc 1 333 0
 2957              		str	lr, [r4, #16]
 2958              		b	.L373
 2959 1630 0630A0E3 	.LVL301:
 2960 1634 0C30C8E5 	.L374:
 2961              	.LBE73:
 2962 1638 0010A0E3 	.LBE72:
 2963 163c 1820A0E3 		.loc 1 224 0
 2964 1640 0400A0E1 		ldr	r0, .L383+4
 2965 1644 FEFFFFEB 		bl	rprintf
 2966              		.loc 1 225 0
 2967 1648 08C09DE5 		mov	r0, fp
 2968 164c 95C92CE0 		bl	free
 2969              	.LVL302:
 2970 1650 0CE09DE5 	.L382:
 2971              		mov	sl, #0
 2972 1654 04009DE5 	.LVL303:
 2973              	.L373:
 2974 1658 95CE2EE0 		.loc 1 230 0
 2975              		mov	r0, sl
 2976 165c 950601E0 		add	sp, sp, #60
 2977              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2978 1660 950000E0 		bx	lr
 2979              	.L384:
 2980 1664 00609DE5 		.align	2
 2981              	.L383:
 2982              		.word	.LC0
 2983 1668 8730A0E1 		.word	.LC1
 2984              	.LFE2:
 2986              		.align	2
 2987 1670 043083E2 		.global	fat16_create_file
 2989 1674 142084E5 	fat16_create_file:
 2990              	.LFB27:
 2991 1678 04108AE5 		.loc 1 1670 0
 2992              		@ Function supports interworking.
 2993 167c 083084E5 		@ args = 0, pretend = 0, frame = 4
 2994              		@ frame_needed = 0, uses_anonymous_args = 0
 2995 1680 BE00C4E1 	.LVL304:
 2996              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2997 1684 04C084E5 	.LCFI33:
 2998              		.loc 1 1672 0
 2999 1688 BC50C4E1 		rsbs	r6, r0, #1
 3000              		movcc	r6, #0
 3001 168c 10E084E5 		cmp	r0, #0
 3002 1690 040000EA 		cmpne	r1, #0
 3003              		.loc 1 1670 0
 3004              		sub	sp, sp, #4
 3005              	.LCFI34:
 3006              		.loc 1 1672 0
 3007              		mov	r5, r0
 3008 1694 20009FE5 		mov	r4, r1
 3009 1698 FEFFFFEB 		.loc 1 1670 0
 3010              		mov	r8, r2
 3011 169c 0B00A0E1 		.loc 1 1672 0
 3012 16a0 FEFFFFEB 		beq	.L386
 3013              	.LVL305:
 3014              		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 3015 16a4 00A0A0E3 		cmp	r3, #0
 3016              		beq	.L386
 3017              	.L416:
 3018              		.loc 1 1678 0
 3019 16a8 0A00A0E1 		mov	r1, r8
 3020 16ac 3CD08DE2 		mov	r0, r5
 3021 16b0 F04FBDE8 		bl	fat16_read_dir
 3022 16b4 1EFF2FE1 		subs	sl, r0, #0
 3023              		.loc 1 1681 0
 3024              		mov	r1, r8
 3025              		mov	r0, r4
 3026 16b8 00000000 		.loc 1 1678 0
 3027 16bc 10000000 		beq	.L389
 3028              	.LVL306:
 3029              		.loc 1 1681 0
 3030              		bl	strcmp
 3031              	.LVL307:
 3032              		cmp	r0, #0
 3033              		bne	.L416
 3034              	.LBB78:
 3035              	.LBB79:
 3036              		.loc 1 1432 0
 3037              		cmp	r6, #0
 3038              		addne	r0, r0, #1
 3039              		.loc 1 1435 0
 3040 16c0 F04F2DE9 		moveq	r0, #1
 3041              		streqh	r6, [r5, #48]	@ movhi
 3042              		b	.L394
 3043 16c4 016070E2 	.LVL308:
 3044 16c8 0060A033 	.L389:
 3045 16cc 000050E3 	.LBE79:
 3046 16d0 00005113 	.LBE78:
 3047              		.loc 1 1688 0
 3048 16d4 04D04DE2 		mov	r1, sl
 3049              	.LVL309:
 3050              		mov	r2, #44
 3051 16d8 0050A0E1 		mov	r0, r8
 3052 16dc 0140A0E1 	.LVL310:
 3053              		bl	memset
 3054 16e0 0280A0E1 		.loc 1 1689 0
 3055              		mov	r1, r4
 3056 16e4 6500000A 		mov	r2, #31
 3057              		mov	r0, r8
 3058 16e8 0030D1E5 		bl	strncpy
 3059 16ec 000053E3 		.loc 1 1692 0
 3060 16f0 6200000A 		mov	r0, r4
 3061              		bl	strlen
 3062              		mov	r1, #13
 3063 16f4 0810A0E1 		bl	__udivsi3
 3064 16f8 0500A0E1 		.loc 1 1695 0
 3065 16fc FEFFFFEB 		ldrh	r7, [r5, #38]
 3066 1700 00A050E2 	.LVL311:
 3067              		.loc 1 1694 0
 3068 1704 0810A0E1 		ldr	r5, [r5, #0]
 3069 1708 0400A0E1 	.LVL312:
 3070              		.loc 1 1700 0
 3071 170c 0700000A 		cmp	r7, #0
 3072              		.loc 1 1703 0
 3073              		ldreq	r4, [r5, #20]
 3074 1710 FEFFFFEB 	.LVL313:
 3075              		.loc 1 1700 0
 3076 1714 000050E3 		movne	r6, sl
 3077 1718 F5FFFF1A 	.LVL314:
 3078              		.loc 1 1692 0
 3079              		add	r0, r0, #2
 3080              		.loc 1 1704 0
 3081 171c 000056E3 		ldreq	sl, [r5, #24]
 3082 1720 01008012 	.LVL315:
 3083              		.loc 1 1692 0
 3084 1724 0100A003 		and	fp, r0, #255
 3085 1728 B063C501 	.LVL316:
 3086 172c 540000EA 		.loc 1 1700 0
 3087              		movne	r4, r6
 3088              		movne	sl, r6
 3089              		.loc 1 1704 0
 3090              		moveq	r6, r4
 3091              		mov	r9, #0
 3092 1730 0A10A0E1 	.LVL317:
 3093              	.LVL318:
 3094 1734 2C20A0E3 	.L421:
 3095 1738 0800A0E1 	.LBB80:
 3096              		.loc 1 1710 0
 3097 173c FEFFFFEB 		cmp	r4, sl
 3098              		bne	.L399
 3099 1740 0410A0E1 		.loc 1 1712 0
 3100 1744 1F20A0E3 		cmp	r7, #0
 3101 1748 0800A0E1 		beq	.L386
 3102 174c FEFFFFEB 		.loc 1 1718 0
 3103              		cmp	r4, #0
 3104 1750 0400A0E1 		beq	.L402
 3105 1754 FEFFFFEB 	.LBB81:
 3106 1758 0D10A0E3 		.loc 1 1724 0
 3107 175c FEFFFFEB 		mov	r0, r5
 3108              		mov	r1, r7
 3109 1760 B672D5E1 		bl	fat16_get_next_cluster
 3110              		.loc 1 1725 0
 3111              		cmp	r0, #0
 3112 1764 005095E5 	.LVL319:
 3113              		bne	.L404
 3114              		.loc 1 1727 0
 3115 1768 000057E3 		mov	r1, r7
 3116              		mov	r0, r5
 3117 176c 14409505 	.LVL320:
 3118              		mov	r2, #1
 3119              		bl	fat16_append_clusters
 3120 1770 0A60A011 		.loc 1 1728 0
 3121              		cmp	r0, #0
 3122              		beq	.L386
 3123 1774 020080E2 		.loc 1 1732 0
 3124              		ldrh	r1, [r5, #18]
 3125 1778 18A09505 		ldr	r2, [r5, #24]
 3126              		sub	r3, r0, #2
 3127              		mla	r6, r1, r3, r2
 3128 177c FFB000E2 		b	.L407
 3129              	.LVL321:
 3130              	.L404:
 3131 1780 0640A011 		.loc 1 1738 0
 3132 1784 06A0A011 		mov	r7, r0
 3133              	.L402:
 3134 1788 0460A001 	.LBE81:
 3135 178c 0090A0E3 		.loc 1 1743 0
 3136              		ldrh	r1, [r5, #18]
 3137              		ldr	r2, [r5, #24]
 3138              		sub	r3, r7, #2
 3139              		mla	r4, r1, r3, r2
 3140              		.loc 1 1745 0
 3141 1790 0A0054E1 		mov	r9, #0
 3142 1794 1B00001A 		add	sl, r4, r1
 3143              		mov	r6, r4
 3144 1798 000057E3 	.L399:
 3145 179c 3700000A 		.loc 1 1752 0
 3146              		ldr	r3, [r5, #0]
 3147 17a0 000054E3 		mov	r0, r4
 3148 17a4 1000000A 	.LVL322:
 3149              		add	r1, sp, #3
 3150              		mov	r2, #1
 3151 17a8 0500A0E1 		ldr	ip, [r3, #0]
 3152 17ac 0710A0E1 		mov	lr, pc
 3153 17b0 9AFAFFEB 		bx	ip
 3154              		cmp	r0, #0
 3155 17b4 000050E3 		beq	.L386
 3156              		.loc 1 1756 0
 3157 17b8 0A00001A 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 3158              		cmp	r3, #0
 3159 17bc 0710A0E1 		cmpne	r3, #229
 3160 17c0 0500A0E1 		movne	r3, #0
 3161              		moveq	r3, #1
 3162 17c4 0120A0E3 		.loc 1 1767 0
 3163 17c8 F4FAFFEB 		addne	r6, r4, #32
 3164              		movne	r9, r3
 3165 17cc 000050E3 		movne	r4, r6
 3166 17d0 2A00000A 		.loc 1 1756 0
 3167              		bne	.L421
 3168 17d4 B211D5E1 		.loc 1 1759 0
 3169 17d8 182095E5 		add	r3, r9, #1
 3170 17dc 023040E2 		and	r9, r3, #255
 3171 17e0 912326E0 		.loc 1 1760 0
 3172 17e4 1E0000EA 		cmp	r9, fp
 3173              		.loc 1 1763 0
 3174              		addcc	r4, r4, #32
 3175              		bcc	.L421
 3176 17e8 0070A0E1 	.L407:
 3177              	.LBE80:
 3178              		.loc 1 1774 0
 3179              		str	r6, [r8, #40]
 3180 17ec B211D5E1 		.loc 1 1775 0
 3181 17f0 182095E5 		mov	r0, r5
 3182 17f4 023047E2 		mov	r1, r8
 3183 17f8 912324E0 		bl	fat16_write_dir_entry
 3184              		subs	r0, r0, #0
 3185 17fc 0090A0E3 		movne	r0, #1
 3186 1800 01A084E0 		b	.L394
 3187 1804 0460A0E1 	.LVL323:
 3188              	.L386:
 3189              		mov	r0, #0
 3190 1808 003095E5 	.L394:
 3191 180c 0400A0E1 		.loc 1 1783 0
 3192              		add	sp, sp, #4
 3193 1810 03108DE2 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3194 1814 0120A0E3 		bx	lr
 3195 1818 00C093E5 	.LFE27:
 3197 1820 1CFF2FE1 		.section	.debug_frame,"",%progbits
 3198 1824 000050E3 	.Lframe0:
 3199 1828 1400000A 		.4byte	.LECIE0-.LSCIE0
 3200              	.LSCIE0:
 3201 182c 0330DDE5 		.4byte	0xffffffff
 3202 1830 000053E3 		.byte	0x1
 3203 1834 E5005313 		.ascii	"\000"
 3204 1838 0030A013 		.uleb128 0x1
 3205 183c 0130A003 		.sleb128 -4
 3206              		.byte	0xe
 3207 1840 20608412 		.byte	0xc
 3208 1844 0390A011 		.uleb128 0xd
 3209 1848 0640A011 		.uleb128 0x0
 3210              		.align	2
 3211 184c CFFFFF1A 	.LECIE0:
 3212              	.LSFDE0:
 3213 1850 013089E2 		.4byte	.LEFDE0-.LASFDE0
 3214 1854 FF9003E2 	.LASFDE0:
 3215              		.4byte	.Lframe0
 3216 1858 0B0059E1 		.4byte	.LFB7
 3217              		.4byte	.LFE7-.LFB7
 3218 185c 20408432 		.align	2
 3219 1860 CAFFFF3A 	.LEFDE0:
 3220              	.LSFDE2:
 3221              		.4byte	.LEFDE2-.LASFDE2
 3222              	.LASFDE2:
 3223 1864 286088E5 		.4byte	.Lframe0
 3224              		.4byte	.LFB8
 3225 1868 0500A0E1 		.4byte	.LFE8-.LFB8
 3226 186c 0810A0E1 		.byte	0x4
 3227 1870 B0FCFFEB 		.4byte	.LCFI0-.LFB8
 3228 1874 000050E2 		.byte	0xe
 3229 1878 0100A013 		.uleb128 0xc
 3230 187c 000000EA 		.byte	0x8e
 3231              		.uleb128 0x1
 3232              		.byte	0x85
 3233 1880 0000A0E3 		.uleb128 0x2
 3234              		.byte	0x84
 3235              		.uleb128 0x3
 3236 1884 04D08DE2 		.align	2
 3237 1888 F04FBDE8 	.LEFDE2:
 3238 188c 1EFF2FE1 	.LSFDE4:
 3239              		.4byte	.LEFDE4-.LASFDE4
 3240              	.LASFDE4:
 3874              		.4byte	0x0
DEFINED SYMBOLS
                            *ABS*:00000000 fat16.c
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:12     .text:00000000 fat16_dir_entry_seek_callback
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:22     .text:00000000 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:76     .text:00000070 fat16_dir_entry_read_callback
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:270    .text:00000220 fat16_get_next_cluster
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:344    .text:000002c4 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:349    .text:000002c8 fat16_free_clusters
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:356    .text:000002c8 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:458    .text:0000039c $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:463    .text:000003a0 fat16_append_clusters
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:470    .text:000003a0 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:638    .text:00000510 fat16_read_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:852    .text:000006ac fat16_reset_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:879    .text:000006c8 fat16_set_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:912    .text:000006e8 fat16_delete_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:989    .text:00000794 fat16_get_fs_size
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1020   .text:000007b8 fat16_get_fs_free
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1107   .text:00000860 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1114   .text:0000086c fat16_get_fs_free_callback
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1121   .text:0000086c $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1165   .text:000008bc fat16_file_size
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1185   .text:000008c4 fat16_read_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1419   .text:00000ad4 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1426   .text:00000adc find_file_in_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1433   .text:00000adc $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1481   .text:00000b38 fat16_write_dir_entry
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1786   .text:00000dc4 fat16_resize_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:1998   .text:00000f68 fat16_seek_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2087   .text:00001000 fat16_write_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2381   .text:00001228 fat16_close_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2407   .text:0000123c fat16_close_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2433   .text:00001250 fat16_close
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2459   .text:00001264 fat16_open_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2530   .text:000012e4 fat16_open_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2603   .text:00001364 open_file_in_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2646   .text:000013a8 fat16_get_dir_entry_of_path
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:2789   .text:000014cc fat16_open
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:3026   .text:000016b8 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:3033   .text:000016c0 fat16_create_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccesbaaa.s:3040   .text:000016c0 $a

UNDEFINED SYMBOLS
__umodsi3
memset
strcmp
__divsi3
strlen
strrchr
memcpy
__udivsi3
free
malloc
strchr
strncmp
rprintf
strncpy
